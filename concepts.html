<!--
SPDX-FileCopyrightText: GLib Development Team

SPDX-License-Identifier: LGPL-2.1-or-later
--><!DOCTYPE html><html lang="en"><!-- Mirrored from docs.gtk.org/gobject/concepts.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 16 Dec 2024 17:55:02 GMT --><!-- Added by HTTrack --><head><meta http-equiv="content-type" content="text/html;charset=utf-8"><!-- /Added by HTTrack -->

  <title>GObject – 2.0: Type System Concepts</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <meta charset="utf-8">

  
  <meta property="og:type" content="website">

  

  
  <meta property="og:title" content="GObject: Type System Concepts">
  <meta property="og:description" content="Reference for GObject-2.0: Type System Concepts">
  <meta name="twitter:title" content="GObject: Type System Concepts">
  <meta name="twitter:description" content="Reference for GObject-2.0: Type System Concepts">


  
  <meta name="twitter:card" content="summary">

  
  
  
  <link rel="search" type="application/opensearchdescription+xml" title="GObject" href="opensearch.xml">
  
  

  

  

  
  <script src="urlmap.js"></script>
  
  
  <script src="fzy.js"></script>
  <script src="search.js"></script>
  
  <script src="main.js"></script>

  
</head>

<body>
  <div id="body-wrapper" tabindex="-1">

    

    

    
<section id="main" class="content">
  
  <h4 id="title" style="display:flex;">
    Type System Concepts
    <a href="#title" class="anchor"></a>
    
  </h4>
  
  <section>
    <div class="docblock">
    <h1 id="type-system-concepts">Type System Concepts<a class="md-anchor" href="#type-system-concepts" title="Permanent link"></a></h1>
<h2 id="introduction">Introduction<a class="md-anchor" href="#introduction" title="Permanent link"></a></h2>
<p>Most modern programming languages come with their own native object systems
and additional fundamental algorithmic language constructs. Just as GLib
serves as an implementation of such fundamental types and algorithms (linked
lists, hash tables and so forth), the GLib Object System provides the
required implementations of a flexible, extensible, and intentionally easy
to map (into other languages) object-oriented framework for C. The
substantial elements that are provided can be summarized&nbsp;as:</p>
<ul>
<li>A generic type system to register arbitrary single-inherited flat and deep
  derived types as well as interfaces for structured types. It takes care of
  creation, initialization and memory management of the assorted object and
  class structures, maintains parent/child relationships and deals with
  dynamic implementations of such types. That is, their type specific
  implementations are relocatable/unloadable during&nbsp;runtime.</li>
<li>A collection of fundamental type implementations, such as integers,
  doubles, enums and structured types, to name a&nbsp;few.</li>
<li>A sample fundamental type implementation to base object hierarchies upon -
  the GObject fundamental&nbsp;type.</li>
<li>A signal system that allows very flexible user customization of
  virtual/overridable object methods and can serve as a powerful
  notification&nbsp;mechanism.</li>
<li>An extensible parameter/value system, supporting all the provided
  fundamental types that can be used to generically handle object properties
  or otherwise parameterized&nbsp;types.</li>
</ul>
<h2 id="background">Background<a class="md-anchor" href="#background" title="Permanent link"></a></h2>
<p>GObject, and its lower-level type system, GType, are used by <span class="caps">GTK</span> and most
<span class="caps">GNOME</span> libraries to&nbsp;provide:</p>
<ul>
<li>object-oriented C-based APIs&nbsp;and</li>
<li>automatic transparent <span class="caps">API</span> bindings to other compiled or interpreted&nbsp;languages.</li>
</ul>
<p>A lot of programmers are used to working with compiled-only or dynamically
interpreted-only languages and do not understand the challenges associated
with cross-language interoperability. This introduction tries to provide an
insight into these challenges and briefly describes the solution chosen by&nbsp;GLib.</p>
<p>The following chapters go into greater detail into how GType and GObject
work and how you can use them as a C programmer. It is useful to keep in
mind that allowing access to C objects from other interpreted languages was
one of the major design goals: this can often explain the sometimes rather
convoluted APIs and features present in this&nbsp;library.</p>
<h3 id="data-types-and-programming">Data types and programming<a class="md-anchor" href="#data-types-and-programming" title="Permanent link"></a></h3>
<p>One could say that a programming language is merely a way to create data
types and manipulate them. Most languages provide a number of
language-native types and a few primitives to create more complex types
based on these primitive&nbsp;types.</p>
<p>In C, the language provides types such as char, long, pointer. During
compilation of C code, the compiler maps these language types to the
compiler’s target architecture machine types. If you are using a C
interpreter (assuming one exists), the interpreter (the program which
interprets the source code and executes it) maps the language types to the
machine types of the target machine at runtime, during the program execution
(or just before execution if it uses a Just In Time compiler&nbsp;engine).</p>
<p>Perl and Python are interpreted languages which do not really provide type
definitions similar to those used by C. Perl and Python programmers
manipulate variables and the type of the variables is decided only upon the
first assignment or upon the first use which forces a type on the variable.
The interpreter also often provides a lot of automatic conversions from one
type to the other. For example, in Perl, a variable which holds an integer
can be automatically converted to a string given the required&nbsp;context:</p>
<div class="codehilite"><pre><span></span><code><span class="k">my</span><span class="w"> </span><span class="nv">$tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="k">print</span><span class="w"> </span><span class="s">"this is an integer converted to a string:"</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="nv">$tmp</span><span class="w"> </span><span class="o">.</span><span class="w"> </span><span class="s">"\n"</span><span class="p">;</span>
</code></pre></div>

<p>Of course, it is also often possible to explicitly specify conversions when
the default conversions provided by the language are not&nbsp;intuitive.</p>
<h3 id="exporting-a-c-api">Exporting a C API<a class="md-anchor" href="#exporting-a-c-api" title="Permanent link"></a></h3>
<p>C APIs are defined by a set of functions and global variables which are
usually exported from a binary. C functions have an arbitrary number of
arguments and one return value. Each function is thus uniquely identified by
the function name and the set of C types which describe the function
arguments and return value. The global variables exported by the <span class="caps">API</span> are
similarly identified by their name and their&nbsp;type.</p>
<p>A C <span class="caps">API</span> is thus merely defined by a set of names to which a set of types are
associated. If you know the function calling convention and the mapping of
the C types to the machine types used by the platform you are on, you can
resolve the name of each function to find where the code associated to this
function is located in memory, and then construct a valid argument list for
the function. Finally, all you have to do is trigger a call to the target C
function with the argument&nbsp;list.</p>
<p>For the sake of discussion, here is a sample C function and the associated
32 bit x86 assembly code generated by <span class="caps">GCC</span> on a Linux&nbsp;computer:</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">function_foo</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">foo</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">main</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w">   </span><span class="n">argc</span><span class="p">,</span>
<span class="w">      </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">function_foo</span><span class="w"> </span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="nf">push</span><span class="w">   </span><span class="no">$0xa</span>
<span class="nf">call</span><span class="w">   </span><span class="mh">0x80482f4</span> <span class="p">&lt;</span><span class="no">function_foo</span><span class="p">&gt;</span>
</code></pre></div>

<p>The assembly code shown above is pretty straightforward: the first
instruction pushes the hexadecimal value 0xa (decimal value 10) as a 32-bit
integer on the stack and calls <code>function_foo</code>. As you can see, C function
calls are implemented by <span class="caps">GCC</span> as native function calls (this is probably the
fastest implementation&nbsp;possible).</p>
<p>Now, let’s say we want to call the C function <code>function_foo</code> from a Python
program. To do this, the Python interpreter needs&nbsp;to:</p>
<ul>
<li>Find where the function is located. This probably means finding the binary
  generated by the C compiler which exports this&nbsp;function.</li>
<li>Load the code of the function in executable&nbsp;memory.</li>
<li>Convert the Python parameters to C-compatible parameters before calling
  the&nbsp;function.</li>
<li>Call the function with the right calling&nbsp;convention.</li>
<li>Convert the return values of the C function to Python-compatible variables
  to return them to the Python&nbsp;code.</li>
</ul>
<p>The process described above is pretty complex and there are a lot of ways to
make it entirely automatic and transparent to C and Python&nbsp;programmers:</p>
<ul>
<li>The first solution is to write by hand a lot of glue code, once for each
  function exported or imported, which does the Python-to-C parameter
  conversion and the C-to-Python return value conversion. This glue code is
  then linked with the interpreter which allows Python programs to call
  Python functions which delegate work to C&nbsp;functions.</li>
<li>Another, nicer solution is to automatically generate the glue code, once
  for each function exported or imported, with a special compiler which
  reads the original function&nbsp;signature.</li>
</ul>
<p>The solution used by GLib is to use the GType library which holds at runtime
a description of all the objects manipulated by the programmer. This
so-called dynamic type library is then used by special generic glue code to
automatically convert function parameters and function calling conventions
between different runtime&nbsp;domains.</p>
<p>The greatest advantage of the solution implemented by GType is that the glue
code sitting at the runtime domain boundaries is written once: the figure
below states this more&nbsp;clearly.</p>
<p><img alt="" src="glue.png"></p>
<p>Currently, there exist multiple generic glue code which makes it possible to
use C objects written with GType directly in a variety of languages, with a
minimum amount of work: there is no need to generate huge amounts of glue
code either automatically or by&nbsp;hand.</p>
<p>Although that goal was arguably laudable, its pursuit has had a major
influence on the whole GType/GObject library. C programmers are likely to be
puzzled at the complexity of the features exposed in the following chapters
if they forget that the GType/GObject library was not only designed to offer
<span class="caps">OO</span>-like features to C programmers but also transparent cross-language&nbsp;interoperability.</p>
<h2 id="the-glib-dynamic-type-system">The GLib Dynamic Type System<a class="md-anchor" href="#the-glib-dynamic-type-system" title="Permanent link"></a></h2>
<p>A type, as manipulated by the GLib type system, is much more generic than what is usually understood as an Object type. It is best explained by looking at the structure and the functions used to register new types in the type&nbsp;system.</p>
<div class="codehilite"><pre><span></span><code><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">_GTypeInfo</span><span class="w">               </span><span class="n">GTypeInfo</span><span class="p">;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">_GTypeInfo</span>
<span class="p">{</span>
<span class="w">  </span><span class="cm">/* interface types, classed types, instantiated types */</span>
<span class="w">  </span><span class="n">guint16</span><span class="w">                </span><span class="n">class_size</span><span class="p">;</span>

<span class="w">  </span><span class="n">GBaseInitFunc</span><span class="w">          </span><span class="n">base_init</span><span class="p">;</span>
<span class="w">  </span><span class="n">GBaseFinalizeFunc</span><span class="w">      </span><span class="n">base_finalize</span><span class="p">;</span>

<span class="w">  </span><span class="cm">/* classed types, instantiated types */</span>
<span class="w">  </span><span class="n">GClassInitFunc</span><span class="w">         </span><span class="n">class_init</span><span class="p">;</span>
<span class="w">  </span><span class="n">GClassFinalizeFunc</span><span class="w">     </span><span class="n">class_finalize</span><span class="p">;</span>
<span class="w">  </span><span class="n">gconstpointer</span><span class="w">          </span><span class="n">class_data</span><span class="p">;</span>

<span class="w">  </span><span class="cm">/* instantiated types */</span>
<span class="w">  </span><span class="n">guint16</span><span class="w">                </span><span class="n">instance_size</span><span class="p">;</span>
<span class="w">  </span><span class="n">guint16</span><span class="w">                </span><span class="n">n_preallocs</span><span class="p">;</span>
<span class="w">  </span><span class="n">GInstanceInitFunc</span><span class="w">      </span><span class="n">instance_init</span><span class="p">;</span>

<span class="w">  </span><span class="cm">/* value handling */</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">GTypeValueTable</span><span class="w"> </span><span class="o">*</span><span class="n">value_table</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">GType</span>
<span class="nf">g_type_register_static</span><span class="w"> </span><span class="p">(</span><span class="n">GType</span><span class="w">            </span><span class="n">parent_type</span><span class="p">,</span>
<span class="w">                        </span><span class="k">const</span><span class="w"> </span><span class="n">gchar</span><span class="w">     </span><span class="o">*</span><span class="n">type_name</span><span class="p">,</span>
<span class="w">                        </span><span class="k">const</span><span class="w"> </span><span class="n">GTypeInfo</span><span class="w"> </span><span class="o">*</span><span class="n">info</span><span class="p">,</span>
<span class="w">                        </span><span class="n">GTypeFlags</span><span class="w">       </span><span class="n">flags</span><span class="p">);</span>

<span class="n">GType</span>
<span class="nf">g_type_register_fundamental</span><span class="w"> </span><span class="p">(</span><span class="n">GType</span><span class="w">                       </span><span class="n">type_id</span><span class="p">,</span>
<span class="w">                             </span><span class="k">const</span><span class="w"> </span><span class="n">gchar</span><span class="w">                </span><span class="o">*</span><span class="n">type_name</span><span class="p">,</span>
<span class="w">                             </span><span class="k">const</span><span class="w"> </span><span class="n">GTypeInfo</span><span class="w">            </span><span class="o">*</span><span class="n">info</span><span class="p">,</span>
<span class="w">                             </span><span class="k">const</span><span class="w"> </span><span class="n">GTypeFundamentalInfo</span><span class="w"> </span><span class="o">*</span><span class="n">finfo</span><span class="p">,</span>
<span class="w">                             </span><span class="n">GTypeFlags</span><span class="w">                  </span><span class="n">flags</span><span class="p">);</span>
</code></pre></div>

<p><code>g_type_register_static()</code>, <code>g_type_register_dynamic()</code> and
<code>g_type_register_fundamental()</code> are the C functions, defined in <code>gtype.h</code>
and implemented in <code>gtype.c</code> which you should use to register a new GType in
the program’s type system. It is not likely you will ever need to use
<code>g_type_register_fundamental()</code> but in case you want to, the last chapter
explains how to create new fundamental&nbsp;types.</p>
<p>Fundamental types are top-level types which do not derive from any other
type while other non-fundamental types derive from other types. Upon
initialization, the type system not only initializes its internal data
structures but it also registers a number of core types: some of these are
fundamental types. Others are types derived from these fundamental&nbsp;types.</p>
<p>Fundamental and non-fundamental types are defined&nbsp;by:</p>
<ul>
<li>class size: the <code>class_size</code> field in <code>GTypeInfo</code>.</li>
<li>class initialization functions (C++ constructor): the <code>base_init</code> and
  <code>class_init</code> fields in <code>GTypeInfo</code>.</li>
<li>class destruction functions (C++ destructor): the <code>base_finalize</code> and
  <code>class_finalize</code> fields in <code>GTypeInfo</code>.</li>
<li>instance size (C++ parameter to new): the <code>instance_size</code> field in
  <code>GTypeInfo</code>.</li>
<li>instantiation policy (C++ type of new operator): the <code>n_preallocs</code> field
  in <code>GTypeInfo</code>.</li>
<li>copy functions (C++ copy operators): the <code>value_table</code> field in
  <code>GTypeInfo</code>.</li>
<li>type characteristic flags: <code>GTypeFlags</code>.</li>
</ul>
<p>Fundamental types are also defined by a set of <code>GTypeFundamentalFlags</code> which
are stored in a <code>GTypeFundamentalInfo</code>. Non-fundamental types are
furthermore defined by the type of their parent which is passed as the
<code>parent_type</code> parameter to <code>g_type_register_static()</code> and
<code>g_type_register_dynamic()</code>.</p>
<h2 id="copy-functions">Copy functions<a class="md-anchor" href="#copy-functions" title="Permanent link"></a></h2>
<p>The major common point between all GLib types (fundamental and
non-fundamental, classed and non-classed, instantiatable and
non-instantiatable) is that they can all be manipulated through a single <span class="caps">API</span>
to copy/assign&nbsp;them.</p>
<p>The <code>GValue</code> structure is used as an abstract container for all of these
types. Its simplistic <span class="caps">API</span> (defined in <code>gobject/gvalue.h</code>) can be used to
invoke the <code>value_table</code> functions registered during type registration: for
example <code>g_value_copy()</code> copies the content of a <code>GValue</code> to another
<code>GValue</code>. This is similar to a C++ assignment which invokes the C++ copy
operator to modify the default bit-by-bit copy semantics of C++/C&nbsp;structures/classes.</p>
<p>The following code shows how you can copy around a 64 bit integer, as well
as a <code>GObject</code> instance&nbsp;pointer:</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">test_int</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">GValue</span><span class="w"> </span><span class="n">a_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">G_VALUE_INIT</span><span class="p">;</span>
<span class="w">  </span><span class="n">GValue</span><span class="w"> </span><span class="n">b_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">G_VALUE_INIT</span><span class="p">;</span>
<span class="w">  </span><span class="n">guint64</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>

<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0xdeadbeef</span><span class="p">;</span>

<span class="w">  </span><span class="n">g_value_init</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">a_value</span><span class="p">,</span><span class="w"> </span><span class="n">G_TYPE_UINT64</span><span class="p">);</span>
<span class="w">  </span><span class="n">g_value_set_uint64</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">a_value</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">);</span>

<span class="w">  </span><span class="n">g_value_init</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">b_value</span><span class="p">,</span><span class="w"> </span><span class="n">G_TYPE_UINT64</span><span class="p">);</span>
<span class="w">  </span><span class="n">g_value_copy</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">a_value</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b_value</span><span class="p">);</span>

<span class="w">  </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g_value_get_uint64</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">b_value</span><span class="p">);</span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">g_print</span><span class="w"> </span><span class="p">(</span><span class="s">"Yay !! 10 lines of code to copy around a uint64.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">g_print</span><span class="w"> </span><span class="p">(</span><span class="s">"Are you sure this is not a Z80 ?</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">test_object</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">GObject</span><span class="w"> </span><span class="o">*</span><span class="n">obj</span><span class="p">;</span>
<span class="w">  </span><span class="n">GValue</span><span class="w"> </span><span class="n">obj_vala</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">G_VALUE_INIT</span><span class="p">;</span>
<span class="w">  </span><span class="n">GValue</span><span class="w"> </span><span class="n">obj_valb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">G_VALUE_INIT</span><span class="p">;</span>
<span class="w">  </span><span class="n">obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g_object_new</span><span class="w"> </span><span class="p">(</span><span class="n">VIEWER_TYPE_FILE</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>

<span class="w">  </span><span class="n">g_value_init</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj_vala</span><span class="p">,</span><span class="w"> </span><span class="n">VIEWER_TYPE_FILE</span><span class="p">);</span>
<span class="w">  </span><span class="n">g_value_set_object</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj_vala</span><span class="p">,</span><span class="w"> </span><span class="n">obj</span><span class="p">);</span>

<span class="w">  </span><span class="n">g_value_init</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj_valb</span><span class="p">,</span><span class="w"> </span><span class="n">G_TYPE_OBJECT</span><span class="p">);</span>

<span class="w">  </span><span class="cm">/* g_value_copy's semantics for G_TYPE_OBJECT types is to copy the reference.</span>
<span class="cm">   * This function thus calls g_object_ref.</span>
<span class="cm">   * It is interesting to note that the assignment works here because</span>
<span class="cm">   * VIEWER_TYPE_FILE is a G_TYPE_OBJECT.</span>
<span class="cm">   */</span>
<span class="w">  </span><span class="n">g_value_copy</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj_vala</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">obj_valb</span><span class="p">);</span>

<span class="w">  </span><span class="n">g_object_unref</span><span class="w"> </span><span class="p">(</span><span class="n">G_OBJECT</span><span class="w"> </span><span class="p">(</span><span class="n">obj</span><span class="p">));</span>
<span class="w">  </span><span class="n">g_object_unref</span><span class="w"> </span><span class="p">(</span><span class="n">G_OBJECT</span><span class="w"> </span><span class="p">(</span><span class="n">obj</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div>

<p>The important point about the above code is that the exact semantics of the
copy calls is undefined since they depend on the implementation of the copy
function. Certain copy functions might decide to allocate a new chunk of
memory and then to copy the data from the source to the destination. Others
might want to simply increment the reference count of the instance and copy
the reference to the new <code>GValue</code>.</p>
<p>The value table used to specify these assignment functions is documented in
<code>GTypeValueTable</code>.</p>
<p>Interestingly, it is also very unlikely you will ever need to specify a
<code>value_table</code> during type registration because these <code>value_tables</code> are
inherited from the parent types for non-fundamental&nbsp;types.</p>
<h2 id="conventions">Conventions<a class="md-anchor" href="#conventions" title="Permanent link"></a></h2>
<p>There are a number of conventions users are expected to follow when creating
new types which are to be exported in a header&nbsp;file:</p>
<ul>
<li>Type names (including object names) must be at least three characters long
  and start with a–z, A–Z or&nbsp;‘_’.</li>
<li>Use the <code>object_method</code> pattern for function names: to invoke the method
  named ‘save’ on an instance of object type ‘file’, call <code>file_save</code>.</li>
<li>Use prefixing to avoid namespace conflicts with other projects. If your
  library (or application) is named <code>Viewer</code>, prefix all your function names
  with <code>viewer_</code>. For example: <code>viewer_file_save</code>.</li>
<li>The prefix should be a single term, i.e. should not contain any capital
  letters after the first letter. For example, <code>Exampleprefix</code> rather than
  <code>ExamplePrefix</code>.</li>
<li>This allows the lowercase-with-underscores versions of names
    to be automatically and unambiguously generated from the camel-case
    versions. See <a href="#name-mangling">Name mangling</a>.</li>
<li>Multiple-term prefixes can be supported if additional arguments are passed
    to type and introspection tooling, but it’s best to avoid the need for&nbsp;this.</li>
<li>Object/Class names (such as <code>File</code> in the examples here) may contain multiple
  terms. For example, <code>LocalFile</code>.</li>
<li>Create a macro named <code>PREFIX_TYPE_OBJECT</code> which always returns the <code>GType</code>
  for the associated object type. For an object of type <code>File</code> in the
  <code>Viewer</code> namespace, use: <code>VIEWER_TYPE_FILE</code>. This macro is implemented
  using a function named <code>prefix_object_get_type</code>; for example,
  <code>viewer_file_get_type</code>.</li>
<li>Use <code>G_DECLARE_FINAL_TYPE</code> or <code>G_DECLARE_DERIVABLE_TYPE</code> to define various
  other conventional macros for your&nbsp;object:</li>
<li><code>PREFIX_OBJECT (obj)</code>, which returns a pointer of type <code>PrefixObject</code>.
    This macro is used to enforce static type safety by doing explicit casts
    wherever needed. It also enforces dynamic type safety by doing runtime
    checks. It is possible to disable the dynamic type checks in production
    builds (see <a href="https://docs.gtk.org/glib/building.html">Building GLib</a>). For
    example, we would create <code>VIEWER_FILE (obj)</code> to keep the previous&nbsp;example.</li>
<li><code>PREFIX_OBJECT_CLASS (klass)</code>, which is strictly equivalent to the
    previous casting macro: it does static casting with dynamic type
    checking of class structures. It is expected to return a pointer to a
    class structure of type <code>PrefixObjectClass</code>. An example is:
    <code>VIEWER_FILE_CLASS</code>.</li>
<li><code>PREFIX_IS_OBJECT (obj)</code>, which returns a boolean which indicates
    whether the input object instance pointer is non-<code>NULL</code> and of type
    <code>OBJECT</code>. For example, <code>VIEWER_IS_FILE</code>.</li>
<li><code>PREFIX_IS_OBJECT_CLASS (klass)</code>, which returns a boolean if the input
    class pointer is a pointer to a class of type <code>OBJECT</code>. For example,
    <code>VIEWER_IS_FILE_CLASS</code>.</li>
<li><code>PREFIX_OBJECT_GET_CLASS (obj)</code>, which returns the class pointer
    associated to an instance of a given type. This macro is used for static
    and dynamic type safety purposes (just like the previous casting
    macros). For example, <code>VIEWER_FILE_GET_CLASS</code>.</li>
</ul>
<p>The implementation of these macros is pretty straightforward: a number of
simple-to-use macros are provided in <code>gtype.h</code>. For the example we used above,
we would write the following trivial code to declare the&nbsp;macros:</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#define VIEWER_TYPE_FILE viewer_file_get_type()</span>
<span class="n">G_DECLARE_FINAL_TYPE</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerFile</span><span class="p">,</span><span class="w"> </span><span class="n">viewer_file</span><span class="p">,</span><span class="w"> </span><span class="n">VIEWER</span><span class="p">,</span><span class="w"> </span><span class="kt">FILE</span><span class="p">,</span><span class="w"> </span><span class="n">GObject</span><span class="p">)</span>
</code></pre></div>

<p>Unless your code has special requirements, you can use the <code>G_DEFINE_TYPE</code>
macro to define a&nbsp;class:</p>
<div class="codehilite"><pre><span></span><code><span class="n">G_DEFINE_TYPE</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerFile</span><span class="p">,</span><span class="w"> </span><span class="n">viewer_file</span><span class="p">,</span><span class="w"> </span><span class="n">G_TYPE_OBJECT</span><span class="p">)</span>
</code></pre></div>

<p>Otherwise, the <code>viewer_file_get_type</code> function must be implemented&nbsp;manually:</p>
<div class="codehilite"><pre><span></span><code><span class="n">GType</span><span class="w"> </span><span class="nf">viewer_file_get_type</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">GType</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">GTypeInfo</span><span class="w"> </span><span class="n">info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="cm">/* You fill this structure. */</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g_type_register_static</span><span class="w"> </span><span class="p">(</span><span class="n">G_TYPE_OBJECT</span><span class="p">,</span>
<span class="w">                                   </span><span class="s">"ViewerFile"</span><span class="p">,</span>
<span class="w">                                   </span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">type</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h2 id="name-mangling">Name mangling<a class="md-anchor" href="#name-mangling" title="Permanent link"></a></h2>
<p>GObject tooling, in particular introspection, relies on being able to
unambiguously convert between type names (in camel-case, such as
<code>GNetworkMonitor</code> or <code>MyViewerFile</code>) and function prefixes (in
lowercase-with-underscores, such as <code>g_network_monitor</code> or <code>my_viewer_file</code>).
The latter can then be used to prefix methods such as
<code>g_network_monitor_can_reach()</code> or <code>my_viewer_file_get_type()</code>.</p>
<p>The algorithm for converting from camel-case to lowercase-with-underscores&nbsp;is:</p>
<!-- This algorithm is here:
     https://gitlab.gnome.org/GNOME/gtk/-/blob/a118cbb3ff552d4258d433e67bdb94e8aef0f439/gtk/gtkbuilderscope.c#L195-229
     We’ve ignored the case of (split_first_cap == TRUE) to simplify things, and
     because that functionality is discouraged. -->

<ol>
<li>The output is a lower-case version of the input, with zero or more&nbsp;‘splits’.</li>
<li>Wherever the input is ‘split’, insert an underscore in the&nbsp;output.</li>
<li>Split the input on:<ul>
<li>Each character (after index zero) which is uppercase and the previous
  character is not&nbsp;uppercase</li>
<li>The second character (index one) if it is uppercase and the first character
  (index zero) is&nbsp;uppercase</li>
<li>Each character (after index two) which is uppercase and the previous two
  characters are also&nbsp;uppercase</li>
</ul>
</li>
</ol>
<h2 id="non-instantiatable-non-classed-fundamental-types">Non-instantiatable non-classed fundamental types<a class="md-anchor" href="#non-instantiatable-non-classed-fundamental-types" title="Permanent link"></a></h2>
<p>A lot of types are not instantiatable by the type system and do not have a class. Most of these types are fundamental trivial types such as <code>gchar</code>, and are already registered by&nbsp;GLib.</p>
<p>In the rare case of needing to register such a type in the type system, fill a <code>GTypeInfo</code> structure with zeros since these types are also most of the time&nbsp;fundamental:</p>
<div class="codehilite"><pre><span></span><code><span class="n">GTypeInfo</span><span class="w"> </span><span class="n">info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">.</span><span class="n">class_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>

<span class="w">  </span><span class="p">.</span><span class="n">base_init</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span>
<span class="w">  </span><span class="p">.</span><span class="n">base_finalize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span>

<span class="w">  </span><span class="p">.</span><span class="n">class_init</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span>
<span class="w">  </span><span class="p">.</span><span class="n">class_finalize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span>
<span class="w">  </span><span class="p">.</span><span class="n">class_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span>

<span class="w">  </span><span class="p">.</span><span class="n">instance_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">  </span><span class="p">.</span><span class="n">n_preallocs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">  </span><span class="p">.</span><span class="n">instance_init</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span>

<span class="w">  </span><span class="p">.</span><span class="n">value_table</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">GTypeValueTable</span><span class="w"> </span><span class="n">value_table</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">.</span><span class="n">value_init</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value_init_long0</span><span class="p">,</span>
<span class="w">  </span><span class="p">.</span><span class="n">value_free</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span>
<span class="w">  </span><span class="p">.</span><span class="n">value_copy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value_copy_long0</span><span class="p">,</span>
<span class="w">  </span><span class="p">.</span><span class="n">value_peek_pointer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span>

<span class="w">  </span><span class="p">.</span><span class="n">collect_format</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"i"</span><span class="p">,</span>
<span class="w">  </span><span class="p">.</span><span class="n">collect_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value_collect_int</span><span class="p">,</span>
<span class="w">  </span><span class="p">.</span><span class="n">lcopy_format</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"p"</span><span class="p">,</span>
<span class="w">  </span><span class="p">.</span><span class="n">lcopy_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value_lcopy_char</span><span class="p">,</span>
<span class="p">};</span>

<span class="n">info</span><span class="p">.</span><span class="n">value_table</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">value_table</span><span class="p">;</span>

<span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g_type_register_fundamental</span><span class="w"> </span><span class="p">(</span><span class="n">G_TYPE_CHAR</span><span class="p">,</span><span class="w"> </span><span class="s">"gchar"</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">finfo</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
</code></pre></div>

<p>Having non-instantiatable types might seem a bit useless: what good is a
type if you cannot instantiate an instance of that type? Most of these types
are used in conjunction with <code>GValue</code>s: a <code>GValue</code> is initialized with an
integer or a string and it is passed around by using the registered type’s
<code>value_table</code>. <code>GValue</code>s (and by extension these trivial fundamental types)
are most useful when used in conjunction with object properties and&nbsp;signals.</p>
<h2 id="instantiatable-classed-types-objects">Instantiatable classed types: objects<a class="md-anchor" href="#instantiatable-classed-types-objects" title="Permanent link"></a></h2>
<p>Types which are registered with a class and are declared instantiatable are
what most closely resembles an object. Although <code>GObject</code>s are the most well
known type of instantiatable classed types, other kinds of similar objects
used as the base of an inheritance hierarchy have been externally developed
and they are all built on the fundamental features described&nbsp;below.</p>
<p>For example, the code below shows how you could register such a fundamental
object type in the type system (using none of the GObject convenience <span class="caps">API</span>):</p>
<div class="codehilite"><pre><span></span><code><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">GObject</span><span class="w"> </span><span class="n">parent_instance</span><span class="p">;</span>

<span class="w">  </span><span class="cm">/* instance members */</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">filename</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">ViewerFile</span><span class="p">;</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">GObjectClass</span><span class="w"> </span><span class="n">parent_class</span><span class="p">;</span>

<span class="w">  </span><span class="cm">/* class members */</span>

<span class="w">  </span><span class="cm">/* the first is public, pure and virtual */</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">open</span><span class="p">)</span><span class="w">  </span><span class="p">(</span><span class="n">ViewerFile</span><span class="w">  </span><span class="o">*</span><span class="n">self</span><span class="p">,</span>
<span class="w">                 </span><span class="n">GError</span><span class="w">     </span><span class="o">**</span><span class="n">error</span><span class="p">);</span>

<span class="w">  </span><span class="cm">/* the second is public and virtual */</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">close</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerFile</span><span class="w">  </span><span class="o">*</span><span class="n">self</span><span class="p">,</span>
<span class="w">                 </span><span class="n">GError</span><span class="w">     </span><span class="o">**</span><span class="n">error</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="n">ViewerFileClass</span><span class="p">;</span>

<span class="cp">#define VIEWER_TYPE_FILE (viewer_file_get_type ())</span>

<span class="n">GType</span>
<span class="nf">viewer_file_get_type</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">GType</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">GTypeInfo</span><span class="w"> </span><span class="n">info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="p">.</span><span class="n">class_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerFileClass</span><span class="p">),</span>
<span class="w">      </span><span class="p">.</span><span class="n">base_init</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span>
<span class="w">      </span><span class="p">.</span><span class="n">base_finalize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span>
<span class="w">      </span><span class="p">.</span><span class="n">class_init</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">GClassInitFunc</span><span class="p">)</span><span class="w"> </span><span class="n">viewer_file_class_init</span><span class="p">,</span>
<span class="w">      </span><span class="p">.</span><span class="n">class_finalize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span>
<span class="w">      </span><span class="p">.</span><span class="n">class_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span>
<span class="w">      </span><span class="p">.</span><span class="n">instance_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerFile</span><span class="p">),</span>
<span class="w">      </span><span class="p">.</span><span class="n">n_preallocs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">      </span><span class="p">.</span><span class="n">instance_init</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">GInstanceInitFunc</span><span class="p">)</span><span class="w"> </span><span class="n">viewer_file_init</span><span class="p">,</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g_type_register_static</span><span class="w"> </span><span class="p">(</span><span class="n">G_TYPE_OBJECT</span><span class="p">,</span>
<span class="w">                                   </span><span class="s">"ViewerFile"</span><span class="p">,</span>
<span class="w">                                   </span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">type</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>Upon the first call to <code>viewer_file_get_type</code>, the type named <code>ViewerFile</code> will be registered in the type system as inheriting from the type <code>G_TYPE_OBJECT</code>.</p>
<p>Every object must define two structures: its class structure and its instance structure. All class structures must contain as first member a <code>GTypeClass</code> structure. All instance structures must contain as first member a <code>GTypeInstance</code> structure. The declaration of these C types, coming from <code>gtype.h</code> is shown&nbsp;below:</p>
<div class="codehilite"><pre><span></span><code>struct _GTypeClass
{
  GType g_type;
};

struct _GTypeInstance
{
  GTypeClass *g_class;
};
</code></pre></div>

<p>These constraints allow the type system to make sure that every object instance (identified by a pointer to the object’s instance structure) contains in its first bytes a pointer to the object’s class&nbsp;structure.</p>
<p>This relationship is best explained by an example: let’s take object B which inherits from object&nbsp;A:</p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* A definitions */</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">GTypeInstance</span><span class="w"> </span><span class="n">parent</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">field_a</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">field_b</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">A</span><span class="p">;</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">GTypeClass</span><span class="w"> </span><span class="n">parent_class</span><span class="p">;</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">method_a</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">method_b</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="n">AClass</span><span class="p">;</span>

<span class="cm">/* B definitions. */</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">A</span><span class="w"> </span><span class="n">parent</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">field_c</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">field_d</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">B</span><span class="p">;</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">AClass</span><span class="w"> </span><span class="n">parent_class</span><span class="p">;</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">method_c</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">method_d</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="n">BClass</span><span class="p">;</span>
</code></pre></div>

<p>The C standard mandates that the first field of a C structure is stored starting in the first byte of the buffer used to hold the structure’s fields in memory. This means that the first field of an instance of an object B is A’s first field which in turn is <code>GTypeInstance</code><span class="quo">‘</span>s first field which in turn is <code>g_class</code>, a pointer to B’s class&nbsp;structure.</p>
<p>Thanks to these simple conditions, it is possible to detect the type of every object instance by&nbsp;doing:</p>
<div class="codehilite"><pre><span></span><code><span class="n">B</span><span class="w"> </span><span class="o">*</span><span class="n">b</span><span class="p">;</span>
<span class="n">b</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">g_class</span><span class="o">-&gt;</span><span class="n">g_type</span>
</code></pre></div>

<p>or, more&nbsp;compactly:</p>
<div class="codehilite"><pre><span></span><code><span class="n">B</span><span class="w"> </span><span class="o">*</span><span class="n">b</span><span class="p">;</span>
<span class="p">((</span><span class="n">GTypeInstance</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">g_class</span><span class="o">-&gt;</span><span class="n">g_type</span>
</code></pre></div>

<h3 id="initialization-and-destruction">Initialization and destruction<a class="md-anchor" href="#initialization-and-destruction" title="Permanent link"></a></h3>
<p>Instantiation of these types can be done with <code>g_type_create_instance()</code>, which
will look up the type information structure associated with the type
requested. Then, the instance size and instantiation policy (if the
<code>n_preallocs</code> field is set to a non-zero value, the type system allocates the
object’s instance structures in chunks rather than mallocing for every
instance) declared by the user are used to get a buffer to hold the object’s
instance&nbsp;structure.</p>
<p>If this is the first instance of the object ever created, the type system
must create a class structure. It allocates a buffer to hold the object’s
class structure and initializes it. The first part of the class structure
(ie: the embedded parent class structure) is initialized by copying the
contents from the class structure of the parent class. The rest of class
structure is initialized to zero. If there is no parent, the entire class
structure is initialized to zero. The type system then invokes the
<code>base_init</code> functions <code>(GBaseInitFunc)</code> from topmost fundamental
object to bottom-most most derived object. The object’s <code>class_init</code>
<code>(GClassInitFunc)</code> function is invoked afterwards to complete initialization
of the class structure. Finally, the object’s interfaces are initialized (we
will discuss interface initialization in more detail&nbsp;later).</p>
<p>Once the type system has a pointer to an initialized class structure, it
sets the object’s instance class pointer to the object’s class structure and
invokes the object’s <code>instance_init</code> <code>(GInstanceInitFunc)</code> functions, from
top-most fundamental type to bottom-most most-derived&nbsp;type.</p>
<p>Object instance destruction through <code>g_type_free_instance()</code> is very simple:
the instance structure is returned to the instance pool if there is one and
if this was the last living instance of the object, the class is&nbsp;destroyed.</p>
<p>Class destruction (the concept of destruction is sometimes partly referred
to as finalization in GType) is the symmetric process of the initialization:
interfaces are destroyed first. Then, the most derived <code>class_finalize</code>
<code>(GClassFinalizeFunc)</code> function is invoked. Finally, the <code>base_finalize</code>
<code>(GBaseFinalizeFunc)</code> functions are invoked from bottom-most most-derived type
to top-most fundamental type and the class structure is&nbsp;freed.</p>
<p>The base initialization/finalization process is very similar to the C++
constructor/destructor paradigm. The practical details are different though
and it is important not to get confused by superficial similarities. GTypes
have no instance destruction mechanism. It is the user’s responsibility to
implement correct destruction semantics on top of the existing GType code.
(This is what <code>GObject</code> does) Furthermore, C++
code equivalent to the <code>base_init</code> and <code>class_init</code> callbacks of GType is
usually not needed because C++ cannot really create object types at&nbsp;runtime.</p>
<p>The instantiation/finalization process can be summarized as&nbsp;follows:</p>
<!-- Markdown's tables cannot deal with multiple row spans -->
<table border="1" class="table" summary="GType Instantiation/Finalization">
  <colgroup>
  <col align="left">
  <col align="left">
  <col align="left">
  </colgroup>
  <thead><tr>
  <th align="left">Invocation time</th>
  <th align="left">Function invoked</th>
  <th align="left">Function’s parameters</th>
  </tr></thead>
  <tbody>
  <tr>
  <td align="left" rowspan="3">First call to <code class="function">g_type_create_instance()</code> for target type</td>
  <td align="left">type’s <code class="function">base_init</code> function</td>
  <td align="left">On the inheritance tree of classes from fundamental type to target type. <code class="function">base_init</code> is invoked once for each class structure.</td>
  </tr>
  <tr>
  <td align="left">target type’s <code class="function">class_init</code> function</td>
  <td align="left">On target type’s class structure</td>
  </tr>
  <tr>
  <td align="left">interface initialization, see the section called “Interface Initialization”</td>
  <td align="left"></td>
  </tr>
  <tr>
  <td align="left">Each call to <code class="function">g_type_create_instance()</code> for target type</td>
  <td align="left">target type’s <code class="function">instance_init</code> function</td>
  <td align="left">On object’s instance</td>
  </tr>
  <tr>
  <td align="left" rowspan="3">Last call to <code class="function">g_type_free_instance()</code> for target type</td>
  <td align="left">interface destruction, see the section called “Interface Destruction”</td>
  <td align="left"></td>
  </tr>
  <tr>
  <td align="left">target type’s <code class="function">class_finalize</code> function</td>
  <td align="left">On target type’s class structure</td>
  </tr>
  <tr>
  <td align="left">type’s <code class="function">base_finalize</code> function</td>
  <td align="left">On the inheritance tree of classes from fundamental type to target type. <code class="function">base_finalize</code> is invoked once for each class structure.</td>
  </tr>
  </tbody>
</table>

<h2 id="non-instantiatable-classed-types-interfaces">Non-instantiatable classed types: interfaces<a class="md-anchor" href="#non-instantiatable-classed-types-interfaces" title="Permanent link"></a></h2>
<p>GType’s interfaces are very similar to Java’s interfaces. They allow to
describe a common <span class="caps">API</span> that several classes will adhere to. Imagine the play,
pause and stop buttons on hi-fi equipment—those can be seen as a playback
interface. Once you know what they do, you can control your <span class="caps">CD</span> player, <span class="caps">MP3</span>
player or anything that uses these&nbsp;symbols.</p>
<p>To declare an interface you have to register a non-instantiatable classed
type which derives from <code>GTypeInterface</code>. The following piece of code declares
such an&nbsp;interface:</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#define VIEWER_TYPE_EDITABLE viewer_editable_get_type ()</span>
<span class="n">G_DECLARE_INTERFACE</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerEditable</span><span class="p">,</span><span class="w"> </span><span class="n">viewer_editable</span><span class="p">,</span><span class="w"> </span><span class="n">VIEWER</span><span class="p">,</span><span class="w"> </span><span class="n">EDITABLE</span><span class="p">,</span><span class="w"> </span><span class="n">GObject</span><span class="p">)</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">_ViewerEditableInterface</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">GTypeInterface</span><span class="w"> </span><span class="n">parent</span><span class="p">;</span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">save</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerEditable</span><span class="w">  </span><span class="o">*</span><span class="n">self</span><span class="p">,</span>
<span class="w">                </span><span class="n">GError</span><span class="w">         </span><span class="o">**</span><span class="n">error</span><span class="p">);</span>
<span class="p">};</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">viewer_editable_save</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerEditable</span><span class="w">  </span><span class="o">*</span><span class="n">self</span><span class="p">,</span>
<span class="w">                           </span><span class="n">GError</span><span class="w">         </span><span class="o">**</span><span class="n">error</span><span class="p">);</span>
</code></pre></div>

<p>The interface function, <code>viewer_editable_save</code> is implemented in a pretty
simple&nbsp;way:</p>
<div class="codehilite"><pre><span></span><code><span class="kt">void</span>
<span class="nf">viewer_editable_save</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerEditable</span><span class="w">  </span><span class="o">*</span><span class="n">self</span><span class="p">,</span>
<span class="w">                      </span><span class="n">GError</span><span class="w">         </span><span class="o">**</span><span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">ViewerEditableinterface</span><span class="w"> </span><span class="o">*</span><span class="n">iface</span><span class="p">;</span>

<span class="w">  </span><span class="n">g_return_if_fail</span><span class="w"> </span><span class="p">(</span><span class="n">VIEWER_IS_EDITABLE</span><span class="w"> </span><span class="p">(</span><span class="n">self</span><span class="p">));</span>
<span class="w">  </span><span class="n">g_return_if_fail</span><span class="w"> </span><span class="p">(</span><span class="n">error</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">*</span><span class="n">error</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>

<span class="w">  </span><span class="n">iface</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VIEWER_EDITABLE_GET_IFACE</span><span class="w"> </span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
<span class="w">  </span><span class="n">g_return_if_fail</span><span class="w"> </span><span class="p">(</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">save</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
<span class="w">  </span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">save</span><span class="w"> </span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p><code>viewer_editable_get_type</code> registers a type named <code>ViewerEditable</code> which
inherits from <code>G_TYPE_INTERFACE</code>. All interfaces must be children of
<code>G_TYPE_INTERFACE</code> in the inheritance&nbsp;tree.</p>
<p>An interface is defined by only one structure which must contain as first
member a <code>GTypeInterface</code> structure. The interface structure is expected to
contain the function pointers of the interface methods. It is good style to
define helper functions for each of the interface methods which simply call
the interface’s method directly: <code>viewer_editable_save</code> is one of&nbsp;these.</p>
<p>If you have no special requirements you can use the <code>G_IMPLEMENT_INTERFACE</code>
macro to implement an&nbsp;interface:</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">viewer_file_save</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerEditable</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">g_print</span><span class="w"> </span><span class="p">(</span><span class="s">"File implementation of editable interface save method.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">viewer_file_editable_interface_init</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerEditableInterface</span><span class="w"> </span><span class="o">*</span><span class="n">iface</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">save</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">viewer_file_save</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">G_DEFINE_TYPE_WITH_CODE</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerFile</span><span class="p">,</span><span class="w"> </span><span class="n">viewer_file</span><span class="p">,</span><span class="w"> </span><span class="n">VIEWER_TYPE_FILE</span><span class="p">,</span>
<span class="w">                         </span><span class="n">G_IMPLEMENT_INTERFACE</span><span class="w"> </span><span class="p">(</span><span class="n">VIEWER_TYPE_EDITABLE</span><span class="p">,</span>
<span class="w">                                                </span><span class="n">viewer_file_editable_interface_init</span><span class="p">))</span>
</code></pre></div>

<p>If your code does have special requirements, you must write a custom
<code>get_type</code> function to register your GType which inherits from some GObject
and which implements the interface <code>ViewerEditable</code>. For example, this code
registers a new <code>ViewerFile</code> class which implements <code>ViewerEditable</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">viewer_file_save</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerEditable</span><span class="w"> </span><span class="o">*</span><span class="n">editable</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">g_print</span><span class="w"> </span><span class="p">(</span><span class="s">"File implementation of editable interface save method.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">viewer_file_editable_interface_init</span><span class="w"> </span><span class="p">(</span><span class="n">gpointer</span><span class="w"> </span><span class="n">g_iface</span><span class="p">,</span>
<span class="w">                                     </span><span class="n">gpointer</span><span class="w"> </span><span class="n">iface_data</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">ViewerEditableInterface</span><span class="w"> </span><span class="o">*</span><span class="n">iface</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g_iface</span><span class="p">;</span>

<span class="w">  </span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">save</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">viewer_file_save</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">GType</span>
<span class="nf">viewer_file_get_type</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">GType</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">GTypeInfo</span><span class="w"> </span><span class="n">info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="p">.</span><span class="n">class_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerFileClass</span><span class="p">),</span>
<span class="w">      </span><span class="p">.</span><span class="n">base_init</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span>
<span class="w">      </span><span class="p">.</span><span class="n">base_finalize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span>
<span class="w">      </span><span class="p">.</span><span class="n">class_init</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">GClassInitFunc</span><span class="p">)</span><span class="w"> </span><span class="n">viewer_file_class_init</span><span class="p">,</span>
<span class="w">      </span><span class="p">.</span><span class="n">class_finalize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span>
<span class="w">      </span><span class="p">.</span><span class="n">class_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span>
<span class="w">      </span><span class="p">.</span><span class="n">instance_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerFile</span><span class="p">),</span>
<span class="w">      </span><span class="p">.</span><span class="n">n_preallocs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">      </span><span class="p">.</span><span class="n">instance_init</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">GInstanceInitFunc</span><span class="p">)</span><span class="w"> </span><span class="n">viewer_file_init</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">GInterfaceInfo</span><span class="w"> </span><span class="n">editable_info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="p">.</span><span class="n">interface_init</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">GInterfaceInitFunc</span><span class="p">)</span><span class="w"> </span><span class="n">viewer_file_editable_interface_init</span><span class="p">,</span>
<span class="w">      </span><span class="p">.</span><span class="n">interface_finalize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span>
<span class="w">      </span><span class="p">.</span><span class="n">interface_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g_type_register_static</span><span class="w"> </span><span class="p">(</span><span class="n">VIEWER_TYPE_FILE</span><span class="p">,</span>
<span class="w">                                   </span><span class="s">"ViewerFile"</span><span class="p">,</span>
<span class="w">                                   </span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="w">    </span><span class="n">g_type_add_interface_static</span><span class="w"> </span><span class="p">(</span><span class="n">type</span><span class="p">,</span>
<span class="w">                                 </span><span class="n">VIEWER_TYPE_EDITABLE</span><span class="p">,</span>
<span class="w">                                 </span><span class="o">&amp;</span><span class="n">editable_info</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">type</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p><code>g_type_add_interface_static()</code> records in the type system that the given
<code>ViewerFile</code> type implements also <code>ViewerEditable</code>
(<code>viewer_editable_get_type()</code> returns the type of <code>ViewerEditable</code>). The
<code>GInterfaceInfo</code> structure holds information about the implementation of the&nbsp;interface:</p>
<div class="codehilite"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">_GInterfaceInfo</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">GInterfaceInitFunc</span><span class="w">     </span><span class="n">interface_init</span><span class="p">;</span>
<span class="w">  </span><span class="n">GInterfaceFinalizeFunc</span><span class="w"> </span><span class="n">interface_finalize</span><span class="p">;</span>
<span class="w">  </span><span class="n">gpointer</span><span class="w">               </span><span class="n">interface_data</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<h3 id="interface-initialization">Interface initialization<a class="md-anchor" href="#interface-initialization" title="Permanent link"></a></h3>
<p>When an instantiatable classed type which implements an interface (either
directly or by inheriting an implementation from a superclass) is created
for the first time, its class structure is initialized following the process
described in the section called “Instantiatable classed types: objects”.
After that, the interface implementations associated with the type are&nbsp;initialized.</p>
<p>First a memory buffer is allocated to hold the interface structure. The
parent’s interface structure is then copied over to the new interface
structure (the parent interface is already initialized at that point). If
there is no parent interface, the interface structure is initialized with
zeros. The <code>g_type</code> and the <code>g_instance_type</code> fields are then initialized:
<code>g_type</code> is set to the type of the most-derived interface and <code>g_instance_type</code>
is set to the type of the most derived type which implements this&nbsp;interface.</p>
<p>The interface’s <code>base_init</code> function is called, and then the interface’s
<code>default_init</code> is invoked. Finally if the type has registered an
implementation of the interface, the implementation’s <code>interface_init</code>
function is invoked. If there are multiple implementations of an interface
the <code>base_init</code> and <code>interface_init</code> functions will be invoked once for each
implementation&nbsp;initialized.</p>
<p>It is thus recommended to use a <code>default_init</code> function to initialize an
interface. This function is called only once for the interface no matter how
many implementations there are. The <code>default_init</code> function is declared by
<code>G_DEFINE_INTERFACE</code> which can be used to define the&nbsp;interface:</p>
<div class="codehilite"><pre><span></span><code><span class="n">G_DEFINE_INTERFACE</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerEditable</span><span class="p">,</span><span class="w"> </span><span class="n">viewer_editable</span><span class="p">,</span><span class="w"> </span><span class="n">G_TYPE_OBJECT</span><span class="p">)</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="n">viewer_editable_default_init</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerEditableInterface</span><span class="w"> </span><span class="o">*</span><span class="n">iface</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="cm">/* add properties and signals here, will only be called once */</span>
<span class="p">}</span>
</code></pre></div>

<p>Or you can do that yourself in a GType function for your&nbsp;interface:</p>
<div class="codehilite"><pre><span></span><code><span class="n">GType</span>
<span class="nf">viewer_editable_get_type</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">gsize</span><span class="w"> </span><span class="n">type_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">g_once_init_enter</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">type_id</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">GTypeInfo</span><span class="w"> </span><span class="n">info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">sizeof</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerEditableInterface</span><span class="p">),</span>
<span class="w">      </span><span class="nb">NULL</span><span class="p">,</span><span class="w">   </span><span class="cm">/* base_init */</span>
<span class="w">      </span><span class="nb">NULL</span><span class="p">,</span><span class="w">   </span><span class="cm">/* base_finalize */</span>
<span class="w">      </span><span class="n">viewer_editable_default_init</span><span class="p">,</span><span class="w"> </span><span class="cm">/* class_init */</span>
<span class="w">      </span><span class="nb">NULL</span><span class="p">,</span><span class="w">   </span><span class="cm">/* class_finalize */</span>
<span class="w">      </span><span class="nb">NULL</span><span class="p">,</span><span class="w">   </span><span class="cm">/* class_data */</span>
<span class="w">      </span><span class="mi">0</span><span class="p">,</span><span class="w">      </span><span class="cm">/* instance_size */</span>
<span class="w">      </span><span class="mi">0</span><span class="p">,</span><span class="w">      </span><span class="cm">/* n_preallocs */</span>
<span class="w">      </span><span class="nb">NULL</span><span class="w">    </span><span class="cm">/* instance_init */</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="n">GType</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g_type_register_static</span><span class="w"> </span><span class="p">(</span><span class="n">G_TYPE_INTERFACE</span><span class="p">,</span>
<span class="w">                                         </span><span class="s">"ViewerEditable"</span><span class="p">,</span>
<span class="w">                                         </span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="n">g_once_init_leave</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">type_id</span><span class="p">,</span><span class="w"> </span><span class="n">type</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">type_id</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">viewer_editable_default_init</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerEditableInterface</span><span class="w"> </span><span class="o">*</span><span class="n">iface</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="cm">/* add properties and signals here, will only called once */</span>
<span class="p">}</span>
</code></pre></div>

<p>In summary, interface initialization uses the following&nbsp;functions:</p>
<table border="1" class="table" summary="Interface Initialization">
  <colgroup>
  <col align="left">
  <col align="left">
  <col align="left">
  </colgroup>
  <thead><tr>
  <th align="left">Invocation time</th>
  <th align="left">Function Invoked</th>
  <th align="left">Function’s parameters</th>
  <th>Remark</th>
  </tr></thead>
  <tbody>
  <tr>
  <td align="left">First call to <code class="function">g_type_create_instance()</code> for <span class="emphasis"><em>any</em></span> type implementing interface</td>
  <td align="left">interface’s <code class="function">base_init</code> function</td>
  <td align="left">On interface’s vtable</td>
  <td>Rarely necessary to use this. Called once per instantiated classed type implementing the interface.</td>
  </tr>
  <tr>
  <td align="left">First call to <code class="function">g_type_create_instance()</code> for <span class="emphasis"><em>each</em></span> type implementing interface</td>
  <td align="left">interface’s <code class="function">default_init</code> function</td>
  <td align="left">On interface’s vtable</td>
  <td>Register interface’s signals, properties, etc. here. Will be called once.</td>
  </tr>
  <tr>
  <td align="left">First call to <code class="function">g_type_create_instance()</code> for <span class="emphasis"><em>any</em></span> type implementing interface</td>
  <td align="left">implementation’s <code class="function">interface_init</code> function</td>
  <td align="left">On interface’s vtable</td>
  <td>Initialize interface implementation. Called for each class that that implements the interface. Initialize the interface method pointers in the interface structure to the implementing class’s implementation.</td>
  </tr>
  </tbody>
</table>

<h3 id="interface-destruction">Interface Destruction<a class="md-anchor" href="#interface-destruction" title="Permanent link"></a></h3>
<p>When the last instance of an instantiatable type which registered an
interface implementation is destroyed, the interface’s implementations
associated to the type are&nbsp;destroyed.</p>
<p>To destroy an interface implementation, GType first calls the
implementation’s <code>interface_finalize</code> function and then the interface’s
most-derived <code>base_finalize</code> function.</p>
<p>Again, it is important to understand, as in the section called “Interface
Initialization”, that both <code>interface_finalize</code> and <code>base_finalize</code> are
invoked exactly once for the destruction of each implementation of an
interface. Thus, if you were to use one of these functions, you would need
to use a static integer variable which would hold the number of instances of
implementations of an interface such that the interface’s class is destroyed
only once (when the integer variable reaches&nbsp;zero).</p>
<p>The above process can be summarized as&nbsp;follows: </p>
<table border="1" class="table" summary="Interface Finalization">
  <colgroup>
  <col align="left">
  <col align="left">
  <col align="left">
  </colgroup>
  <thead><tr>
  <th align="left">Invocation time</th>
  <th align="left">Function Invoked</th>
  <th align="left">Function’s parameters</th>
  </tr></thead>
  <tbody>
  <tr>
  <td align="left" rowspan="2">Last call to <code class="function">g_type_free_instance()</code> for type implementing interface</td>
  <td align="left">interface’s <code class="function">interface_finalize</code> function</td>
  <td align="left">On interface’s vtable</td>
  </tr>
  <tr>
  <td align="left">interface’s <code class="function">base_finalize</code> function</td>
  <td align="left">On interface’s vtable</td>
  </tr>
  </tbody>
</table>

<h2 id="the-gobject-base-class">The GObject base class<a class="md-anchor" href="#the-gobject-base-class" title="Permanent link"></a></h2>
<p>The previous chapter discussed the details of GLib’s Dynamic Type System.
The GObject library also contains an implementation for a base fundamental
type named <code>GObject</code>.</p>
<p><code>GObject</code> is a fundamental classed instantiatable type. It&nbsp;implements:</p>
<ul>
<li>memory management with reference&nbsp;counting</li>
<li>construction/Destruction of&nbsp;instances</li>
<li>generic per-object properties with set/get function&nbsp;pairs</li>
<li>easy use of&nbsp;signals</li>
</ul>
<p>All the <span class="caps">GNOME</span> libraries which use the GLib type system (like <span class="caps">GTK</span> and
GStreamer) inherit from <code>GObject</code> which is why it is important to understand
the details of how it&nbsp;works.</p>
<h3 id="object-instantiation">Object instantiation<a class="md-anchor" href="#object-instantiation" title="Permanent link"></a></h3>
<p>The <code>g_object_new()</code> family of functions can be used to instantiate any
GType which inherits from the GObject base type. All these functions make
sure the class and instance structures have been correctly initialized by
GLib’s type system and then invoke at one point or another the constructor
class method which is used&nbsp;to:</p>
<ul>
<li>allocate and clear memory through <code>g_type_create_instance()</code></li>
<li>initialize the object’s instance with the construction&nbsp;properties.</li>
</ul>
<p>GObject explicitly guarantees that all class and instance members (except
the fields pointing to the parents) to be set to&nbsp;zero.</p>
<p>Once all construction operations have been completed and constructor
properties set, the constructed class method is&nbsp;called.</p>
<p>Objects which inherit from <code>GObject</code> are allowed to override this
constructed class method. The example below shows how <code>ViewerFile</code> overrides
the parent’s construction&nbsp;process:</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#define VIEWER_TYPE_FILE viewer_file_get_type ()</span>
<span class="n">G_DECLARE_FINAL_TYPE</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerFile</span><span class="p">,</span><span class="w"> </span><span class="n">viewer_file</span><span class="p">,</span><span class="w"> </span><span class="n">VIEWER</span><span class="p">,</span><span class="w"> </span><span class="kt">FILE</span><span class="p">,</span><span class="w"> </span><span class="n">GObject</span><span class="p">)</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">_ViewerFile</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">GObject</span><span class="w"> </span><span class="n">parent_instance</span><span class="p">;</span>

<span class="w">  </span><span class="cm">/* instance members */</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">filename</span><span class="p">;</span>
<span class="w">  </span><span class="n">guint</span><span class="w"> </span><span class="n">zoom_level</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* will create viewer_file_get_type and set viewer_file_parent_class */</span>
<span class="n">G_DEFINE_TYPE</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerFile</span><span class="p">,</span><span class="w"> </span><span class="n">viewer_file</span><span class="p">,</span><span class="w"> </span><span class="n">G_TYPE_OBJECT</span><span class="p">)</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="n">viewer_file_constructed</span><span class="w"> </span><span class="p">(</span><span class="n">GObject</span><span class="w"> </span><span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="cm">/* update the object state depending on constructor properties */</span>

<span class="w">  </span><span class="cm">/* Always chain up to the parent constructed function to complete object</span>
<span class="cm">   * initialisation. */</span>
<span class="w">  </span><span class="n">G_OBJECT_CLASS</span><span class="w"> </span><span class="p">(</span><span class="n">viewer_file_parent_class</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">constructed</span><span class="w"> </span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="n">viewer_file_finalize</span><span class="w"> </span><span class="p">(</span><span class="n">GObject</span><span class="w"> </span><span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">ViewerFile</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VIEWER_FILE</span><span class="w"> </span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>

<span class="w">  </span><span class="n">g_free</span><span class="w"> </span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">filename</span><span class="p">);</span>

<span class="w">  </span><span class="cm">/* Always chain up to the parent finalize function to complete object</span>
<span class="cm">   * destruction. */</span>
<span class="w">  </span><span class="n">G_OBJECT_CLASS</span><span class="w"> </span><span class="p">(</span><span class="n">viewer_file_parent_class</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">finalize</span><span class="w"> </span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="n">viewer_file_class_init</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerFileClass</span><span class="w"> </span><span class="o">*</span><span class="n">klass</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">GObjectClass</span><span class="w"> </span><span class="o">*</span><span class="n">object_class</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">G_OBJECT_CLASS</span><span class="w"> </span><span class="p">(</span><span class="n">klass</span><span class="p">);</span>

<span class="w">  </span><span class="n">object_class</span><span class="o">-&gt;</span><span class="n">constructed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">viewer_file_constructed</span><span class="p">;</span>
<span class="w">  </span><span class="n">object_class</span><span class="o">-&gt;</span><span class="n">finalize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">viewer_file_finalize</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="n">viewer_file_init</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerFile</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="cm">/* initialize the object */</span>
<span class="p">}</span>
</code></pre></div>

<p>If the user instantiates an object <code>ViewerFile</code> with:</p>
<div class="codehilite"><pre><span></span><code><span class="n">ViewerFile</span><span class="w"> </span><span class="o">*</span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g_object_new</span><span class="w"> </span><span class="p">(</span><span class="n">VIEWER_TYPE_FILE</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
</code></pre></div>

<p>If this is the first instantiation of such an object, the
<code>viewer_file_class_init</code> function will be invoked after any
<code>viewer_file_base_class_init</code> function. This will make sure the class
structure of this new object is correctly initialized. Here,
<code>viewer_file_class_init</code> is expected to override the object’s class methods
and setup the class’ own methods. In the example above, the constructed
method is the only overridden method: it is set to
<code>viewer_file_constructed</code>.</p>
<p>Once <code>g_object_new()</code> has obtained a reference to an initialized class
structure, it invokes its constructor method to create an instance of the
new object, if the constructor has been overridden in
<code>viewer_file_class_init</code>. Overridden constructors must chain up to their
parent’s constructor. In order to find the parent class and chain up to the
parent class constructor, we can use the <code>viewer_file_parent_class</code> pointer
that has been set up for us by the <code>G_DEFINE_TYPE</code> macro.</p>
<p>Finally, at one point or another, <code>g_object_constructor</code> is invoked by the
last constructor in the chain. This function allocates the object’s instance
buffer through <code>g_type_create_instance()</code> which means that the
<code>instance_init</code> function is invoked at this point if one was registered.
After <code>instance_init</code> returns, the object is fully initialized and should be
ready to have its methods called by the user. When
<code>g_type_create_instance()</code> returns, <code>g_object_constructor</code> sets the
construction properties (i.e. the properties which were given to
<code>g_object_new()</code>) and returns to the user’s&nbsp;constructor.</p>
<p>The process described above might seem a bit complicated, but it can be
summarized easily by the table below which lists the functions invoked by
<code>g_object_new()</code> and their order of&nbsp;invocation:</p>
<!-- Markdown's tables do not allow multiple row spans -->
<table border="1" class="table" summary="g_object_new">
  <colgroup>
  <col align="left">
  <col align="left">
  <col align="left">
  </colgroup>
  <thead><tr>
  <th align="left">Invocation time</th>
  <th align="left">Function invoked</th>
  <th align="left">Function’s parameters</th>
  <th>Remark</th>
  </tr></thead>
  <tbody>
  <tr>
  <td align="left" rowspan="4">First call to <code class="function">g_object_new()</code> for target type</td>
  <td align="left">target type’s <code class="function">base_init</code> function</td>
  <td align="left">On the inheritance tree of classes from fundamental type to target type. <code class="function">base_init</code> is invoked once for each class structure.</td>
  <td>Never used in practice. Unlikely you will need it.</td>
  </tr>
  <tr>
  <td align="left">target type’s <code class="function">class_init</code> function</td>
  <td align="left">On target type’s class structure</td>
  <td>Here, you should make sure to initialize or override class methods (that is, assign to each class’ method its function pointer) and create the signals and the properties associated to your object.</td>
  </tr>
  <tr>
  <td align="left">interface’s <code class="function">base_init</code> function</td>
  <td align="left">On interface’s vtable</td>
  <td></td>
  </tr>
  <tr>
  <td align="left">interface’s <code class="function">interface_init</code> function</td>
  <td align="left">On interface’s vtable</td>
  <td></td>
  </tr>
  <tr>
  <td align="left" rowspan="3">Each call to <code class="function">g_object_new()</code> for target type</td>
  <td align="left">target type’s class <code class="function">constructor</code> method: <code class="function">GObjectClass-&gt;constructor</code>
  </td>
  <td align="left">On object’s instance</td>
  <td>If you need to handle construct properties in a custom way, or implement a singleton class, override the constructor method and make sure to chain up to the object’s parent class before doing your own initialization. In doubt, do not override the constructor method.</td>
  </tr>
  <tr>
  <td align="left">type’s <code class="function">instance_init</code> function</td>
  <td align="left">On the inheritance tree of classes from fundamental type to target type. The <code class="function">instance_init</code> provided for each type is invoked once for each instance structure.</td>
  <td>Provide an <code class="function">instance_init</code> function to initialize your object before its construction properties are set. This is the preferred way to initialize a GObject instance. This function is equivalent to C++ constructors.</td>
  </tr>
  <tr>
  <td align="left">target type’s class <code class="function">constructed</code> method: <code class="function">GObjectClass-&gt;constructed</code></td>
  <td align="left">On object’s instance</td>
  <td>If you need to perform object initialization steps after all construct properties have been set. This is the final step in the object initialization process, and is only called if the <code class="function">constructor</code> method returned a new object instance (rather than, for example, an existing singleton).</td>
  </tr>
  </tbody>
</table>

<p>Readers should feel concerned about one little twist in the order in which
functions are invoked: while, technically, the class’ constructor method is
called before the GType’s <code>instance_init</code> function (since
<code>g_type_create_instance()</code> which calls <code>instance_init</code> is called by
<code>g_object_constructor</code> which is the top-level class constructor method and
to which users are expected to chain to), the user’s code which runs in a
user-provided constructor will always run after GType’s <code>instance_init</code>
function since the user-provided constructor must (you’ve been warned) chain
up before doing anything&nbsp;useful.</p>
<h3 id="object-memory-management">Object memory management<a class="md-anchor" href="#object-memory-management" title="Permanent link"></a></h3>
<p>The memory-management <span class="caps">API</span> for GObjects is a bit complicated but the idea
behind it is pretty simple: the goal is to provide a flexible model based on
reference counting which can be integrated in applications which use or
require different memory management models (such as garbage collection). The
methods which are used to manipulate this reference count are described&nbsp;below.</p>
<h4 id="reference-count">Reference count<a class="md-anchor" href="#reference-count" title="Permanent link"></a></h4>
<p>The functions <code>g_object_ref()</code> and <code>g_object_unref()</code> increase and decrease
the reference count, respectively. These functions are thread-safe.
<code>g_clear_object()</code> is a convenience wrapper around <code>g_object_unref()</code> which
also clears the pointer passed to&nbsp;it.</p>
<p>The reference count is initialized to one by <code>g_object_new()</code> which means
that the caller is currently the sole owner of the newly-created reference.
(If the object is derived from <code>GInitiallyUnowned</code>, this reference is
“floating”, and must be “sunk”, i.e. transformed into a real reference.)
When the reference count reaches zero, that is, when <code>g_object_unref()</code> is
called by the last owner of a reference to the object, the <code>dispose()</code> and
the <code>finalize()</code> class methods are&nbsp;invoked.</p>
<p>Finally, after <code>finalize()</code> is invoked, <code>g_type_free_instance()</code> is called
to free the object instance. Depending on the memory allocation policy
decided when the type was registered (through one of the <code>g_type_register_*</code>
functions), the object’s instance memory will be freed or returned to the
object pool for this type. Once the object has been freed, if it was the
last instance of the type, the type’s class will be destroyed as described
in the section called “Instantiatable classed types: objects” and the
section called “Non-instantiatable classed types:&nbsp;interfaces”.</p>
<p>The table below summarizes the destruction process of a <code>GObject</code>:</p>
<table border="1" class="table" summary="g_object_unref">
  <colgroup>
  <col align="left">
  <col align="left">
  <col align="left">
  </colgroup>
  <thead><tr>
  <th align="left">Invocation time</th>
  <th align="left">Function invoked</th>
  <th align="left">Function’s parameters</th>
  <th>Remark</th>
  </tr></thead>
  <tbody>
  <tr>
  <td align="left" rowspan="2">Last call to <code class="function">g_object_unref()</code> for an instance of target type</td>
  <td align="left">target type’s dispose class function</td>
  <td align="left">GObject instance</td>
  <td>When dispose ends, the object should not hold any reference to any other member object. The object is also expected to be able to answer client method invocations (with possibly an error code but no memory violation) until finalize is executed. dispose can be executed more than once. dispose should chain up to its parent implementation just before returning to the caller.</td>
  </tr>
  <tr>
  <td align="left">target type’s finalize class function</td>
  <td align="left">GObject instance</td>
  <td>Finalize is expected to complete the destruction process initiated by dispose. It should complete the object’s destruction. finalize will be executed only once. finalize should chain up to its parent implementation just before returning to the caller. See the section on “Reference counts and cycles” for more information.</td>
  </tr>
  <tr>
  <td align="left" rowspan="4">Last call to <code class="function">g_object_unref()</code> for the last instance of target type</td>
  <td align="left">interface’s <code class="function">interface_finalize</code> function</td>
  <td align="left">On interface’s vtable</td>
  <td>Never used in practice. Unlikely you will need it.</td>
  </tr>
  <tr>
  <td align="left">interface’s <code class="function">base_finalize</code> function</td>
  <td align="left">On interface’s vtable</td>
  <td>Never used in practice. Unlikely you will need it.</td>
  </tr>
  <tr>
  <td align="left">target type’s <code class="function">class_finalize</code> function</td>
  <td align="left">On target type’s class structure</td>
  <td>Never used in practice. Unlikely you will need it.</td>
  </tr>
  <tr>
  <td align="left">type’s <code class="function">base_finalize</code> function</td>
  <td align="left">On the inheritance tree of classes from fundamental type to target type. <code class="function">base_init</code> is invoked once for each class structure.</td>
  <td>Never used in practice. Unlikely you will need it.</td>
  </tr>
  </tbody>
</table>

<h4 id="weak-references">Weak References<a class="md-anchor" href="#weak-references" title="Permanent link"></a></h4>
<p>Weak references are used to monitor object finalization:
<code>g_object_weak_ref()</code> adds a monitoring callback which does not hold a
reference to the object but which is invoked when the object runs its
dispose method. Weak references on the object are automatically dropped when
the instance is disposed, so there is no need to invoke <code>g_object_weak_unref()</code>
from the <code>GWeakNotify</code> callback. Remember that the object instance is not
passed to the <code>GWeakNotify</code> callback because the object has already been
disposed. Instead, the callback receives a pointer to where the object
previously&nbsp;was.</p>
<p>Weak references are also used to implement <code>g_object_add_weak_pointer()</code> and
<code>g_object_remove_weak_pointer()</code>. These functions add a weak reference to
the object they are applied to which makes sure to nullify the pointer given
by the user when object is&nbsp;finalized.</p>
<p>Similarly, <code>GWeakRef</code> can be used to implement weak references if thread
safety is&nbsp;required.</p>
<h4 id="reference-counts-and-cycles">Reference counts and cycles<a class="md-anchor" href="#reference-counts-and-cycles" title="Permanent link"></a></h4>
<p>GObject’s memory management model was designed to be easily integrated in
existing code using garbage collection. This is why the destruction process
is split in two phases: the first phase, executed in the <code>dispose()</code> handler is
supposed to release all references to other member objects. The second
phase, executed by the <code>finalize()</code> handler is supposed to complete the object’s
destruction process. Object methods should be able to run without program
error in-between the two&nbsp;phases.</p>
<p>This two-step destruction process is very useful to break reference counting
cycles. While the detection of the cycles is up to the external code, once
the cycles have been detected, the external code can invoke
<code>g_object_run_dispose()</code> which will indeed break any existing cycles since
it will run the dispose handler associated to the object and thus release
all references to other&nbsp;objects.</p>
<p>This explains one of the rules about the <code>dispose()</code> handler stated earlier:
the <code>dispose()</code> handler can be invoked multiple times. Let’s say we have a
reference count cycle: object A references B which itself references object
A. Let’s say we have detected the cycle and we want to destroy the two
objects. One way to do this would be to invoke <code>g_object_run_dispose()</code> on one
of the&nbsp;objects.</p>
<p>If object A releases all its references to all objects, this means it
releases its reference to object B. If object B was not owned by anyone
else, this is its last reference count which means this last unref runs B’s
dispose handler which, in turn, releases B’s reference on object A. If this
is A’s last reference count, this last unref runs A’s dispose handler which
is running for the second time before A’s finalize handler is&nbsp;invoked!</p>
<p>The above example, which might seem a bit contrived, can really happen if
GObjects are being handled by language bindings—hence the rules for object
destruction should be closely&nbsp;followed.</p>
<h3 id="object-properties">Object properties<a class="md-anchor" href="#object-properties" title="Permanent link"></a></h3>
<p>One of GObject’s nice features is its generic get/set mechanism for object
properties. When an object is instantiated, the object’s <code>class_init</code>
handler should be used to register the object’s properties with
<code>g_object_class_install_properties()</code>.</p>
<p>The best way to understand how object properties work is by looking at a
real example of how it is&nbsp;used:</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// Implementation</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">enum</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">PROP_FILENAME</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">  </span><span class="n">PROP_ZOOM_LEVEL</span><span class="p">,</span>
<span class="w">  </span><span class="n">N_PROPERTIES</span>
<span class="p">}</span><span class="w"> </span><span class="n">ViewerFileProperty</span><span class="p">;</span>

<span class="k">static</span><span class="w"> </span><span class="n">GParamSpec</span><span class="w"> </span><span class="o">*</span><span class="n">obj_properties</span><span class="p">[</span><span class="n">N_PROPERTIES</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="p">};</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">viewer_file_set_property</span><span class="w"> </span><span class="p">(</span><span class="n">GObject</span><span class="w">      </span><span class="o">*</span><span class="n">object</span><span class="p">,</span>
<span class="w">                          </span><span class="n">guint</span><span class="w">         </span><span class="n">property_id</span><span class="p">,</span>
<span class="w">                          </span><span class="k">const</span><span class="w"> </span><span class="n">GValue</span><span class="w"> </span><span class="o">*</span><span class="n">value</span><span class="p">,</span>
<span class="w">                          </span><span class="n">GParamSpec</span><span class="w">   </span><span class="o">*</span><span class="n">pspec</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">ViewerFile</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VIEWER_FILE</span><span class="w"> </span><span class="p">(</span><span class="n">object</span><span class="p">);</span>

<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">((</span><span class="n">ViewerFileProperty</span><span class="p">)</span><span class="w"> </span><span class="n">property_id</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">PROP_FILENAME</span><span class="p">:</span>
<span class="w">      </span><span class="n">g_free</span><span class="w"> </span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">filename</span><span class="p">);</span>
<span class="w">      </span><span class="n">self</span><span class="o">-&gt;</span><span class="n">filename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g_value_dup_string</span><span class="w"> </span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
<span class="w">      </span><span class="n">g_print</span><span class="w"> </span><span class="p">(</span><span class="s">"filename: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">self</span><span class="o">-&gt;</span><span class="n">filename</span><span class="p">);</span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span>

<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">PROP_ZOOM_LEVEL</span><span class="p">:</span>
<span class="w">      </span><span class="n">self</span><span class="o">-&gt;</span><span class="n">zoom_level</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g_value_get_uint</span><span class="w"> </span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
<span class="w">      </span><span class="n">g_print</span><span class="w"> </span><span class="p">(</span><span class="s">"zoom level: %u</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">self</span><span class="o">-&gt;</span><span class="n">zoom_level</span><span class="p">);</span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span>

<span class="w">    </span><span class="k">default</span><span class="o">:</span>
<span class="w">      </span><span class="cm">/* We don't have any other property... */</span>
<span class="w">      </span><span class="n">G_OBJECT_WARN_INVALID_PROPERTY_ID</span><span class="w"> </span><span class="p">(</span><span class="n">object</span><span class="p">,</span><span class="w"> </span><span class="n">property_id</span><span class="p">,</span><span class="w"> </span><span class="n">pspec</span><span class="p">);</span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">viewer_file_get_property</span><span class="w"> </span><span class="p">(</span><span class="n">GObject</span><span class="w">    </span><span class="o">*</span><span class="n">object</span><span class="p">,</span>
<span class="w">                          </span><span class="n">guint</span><span class="w">       </span><span class="n">property_id</span><span class="p">,</span>
<span class="w">                          </span><span class="n">GValue</span><span class="w">     </span><span class="o">*</span><span class="n">value</span><span class="p">,</span>
<span class="w">                          </span><span class="n">GParamSpec</span><span class="w"> </span><span class="o">*</span><span class="n">pspec</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">ViewerFile</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VIEWER_FILE</span><span class="w"> </span><span class="p">(</span><span class="n">object</span><span class="p">);</span>

<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">((</span><span class="n">ViewerFileProperty</span><span class="p">)</span><span class="w"> </span><span class="n">property_id</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">PROP_FILENAME</span><span class="p">:</span>
<span class="w">      </span><span class="n">g_value_set_string</span><span class="w"> </span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">self</span><span class="o">-&gt;</span><span class="n">filename</span><span class="p">);</span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span>

<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">PROP_ZOOM_LEVEL</span><span class="p">:</span>
<span class="w">      </span><span class="n">g_value_set_uint</span><span class="w"> </span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">self</span><span class="o">-&gt;</span><span class="n">zoom_level</span><span class="p">);</span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span>

<span class="w">    </span><span class="k">default</span><span class="o">:</span>
<span class="w">      </span><span class="cm">/* We don't have any other property... */</span>
<span class="w">      </span><span class="n">G_OBJECT_WARN_INVALID_PROPERTY_ID</span><span class="w"> </span><span class="p">(</span><span class="n">object</span><span class="p">,</span><span class="w"> </span><span class="n">property_id</span><span class="p">,</span><span class="w"> </span><span class="n">pspec</span><span class="p">);</span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">viewer_file_class_init</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerFileClass</span><span class="w"> </span><span class="o">*</span><span class="n">klass</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">GObjectClass</span><span class="w"> </span><span class="o">*</span><span class="n">object_class</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">G_OBJECT_CLASS</span><span class="w"> </span><span class="p">(</span><span class="n">klass</span><span class="p">);</span>

<span class="w">  </span><span class="n">object_class</span><span class="o">-&gt;</span><span class="n">set_property</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">viewer_file_set_property</span><span class="p">;</span>
<span class="w">  </span><span class="n">object_class</span><span class="o">-&gt;</span><span class="n">get_property</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">viewer_file_get_property</span><span class="p">;</span>

<span class="w">  </span><span class="n">obj_properties</span><span class="p">[</span><span class="n">PROP_FILENAME</span><span class="p">]</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="n">g_param_spec_string</span><span class="w"> </span><span class="p">(</span><span class="s">"filename"</span><span class="p">,</span>
<span class="w">                         </span><span class="s">"Filename"</span><span class="p">,</span>
<span class="w">                         </span><span class="s">"Name of the file to load and display from."</span><span class="p">,</span>
<span class="w">                         </span><span class="nb">NULL</span><span class="w">  </span><span class="cm">/* default value */</span><span class="p">,</span>
<span class="w">                         </span><span class="n">G_PARAM_CONSTRUCT_ONLY</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">G_PARAM_READWRITE</span><span class="p">);</span>

<span class="w">  </span><span class="n">obj_properties</span><span class="p">[</span><span class="n">PROP_ZOOM_LEVEL</span><span class="p">]</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="n">g_param_spec_uint</span><span class="w"> </span><span class="p">(</span><span class="s">"zoom-level"</span><span class="p">,</span>
<span class="w">                       </span><span class="s">"Zoom level"</span><span class="p">,</span>
<span class="w">                       </span><span class="s">"Zoom level to view the file at."</span><span class="p">,</span>
<span class="w">                       </span><span class="mi">0</span><span class="w">  </span><span class="cm">/* minimum value */</span><span class="p">,</span>
<span class="w">                       </span><span class="mi">10</span><span class="w"> </span><span class="cm">/* maximum value */</span><span class="p">,</span>
<span class="w">                       </span><span class="mi">2</span><span class="w">  </span><span class="cm">/* default value */</span><span class="p">,</span>
<span class="w">                       </span><span class="n">G_PARAM_READWRITE</span><span class="p">);</span>

<span class="w">  </span><span class="n">g_object_class_install_properties</span><span class="w"> </span><span class="p">(</span><span class="n">object_class</span><span class="p">,</span>
<span class="w">                                     </span><span class="n">N_PROPERTIES</span><span class="p">,</span>
<span class="w">                                     </span><span class="n">obj_properties</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="c1">// Use</span>

<span class="n">ViewerFile</span><span class="w"> </span><span class="o">*</span><span class="n">file</span><span class="p">;</span>
<span class="n">GValue</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">G_VALUE_INIT</span><span class="p">;</span>

<span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g_object_new</span><span class="w"> </span><span class="p">(</span><span class="n">VIEWER_TYPE_FILE</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>

<span class="n">g_value_init</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="n">G_TYPE_UINT</span><span class="p">);</span>
<span class="n">g_value_set_char</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="mi">11</span><span class="p">);</span>

<span class="n">g_object_set_property</span><span class="w"> </span><span class="p">(</span><span class="n">G_OBJECT</span><span class="w"> </span><span class="p">(</span><span class="n">file</span><span class="p">),</span><span class="w"> </span><span class="s">"zoom-level"</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>

<span class="n">g_value_unset</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
</code></pre></div>

<p>The client code above looks simple but a lot of things happen under the&nbsp;hood:</p>
<p><code>g_object_set_property()</code> first ensures a property with this name was
registered in file’s <code>class_init</code> handler. If so it walks the class
hierarchy, from bottom-most most-derived type, to top-most fundamental type
to find the class which registered that property. It then tries to convert
the user-provided GValue into a GValue whose type is that of the associated&nbsp;property.</p>
<p>If the user provides a signed char GValue, as is shown here, and if the
object’s property was registered as an <code>unsigned int</code>, <code>g_value_transform()</code>
will try to transform the input signed char into an unsigned int. Of course,
the success of the transformation depends on the availability of the
required transform function. In practice, there will almost always be a
transformation which matches and conversion will be carried out if&nbsp;needed.</p>
<p>After transformation, the GValue is validated by <code>g_param_value_validate()</code>
which makes sure the user’s data stored in the GValue matches the
characteristics specified by the property’s GParamSpec. Here, the GParamSpec
we provided in <code>class_init</code> has a validation function which makes sure that
the GValue contains a value which respects the minimum and maximum bounds of
the GParamSpec. In the example above, the client’s GValue does not respect
these constraints (it is set to 11, while the maximum is 10). As such, the
<code>g_object_set_property()</code> function will return with an&nbsp;error.</p>
<p>If the user’s GValue had been set to a valid value,
<code>g_object_set_property()</code> would have proceeded with calling the object’s
<code>set_property</code> class method. Here, since our implementation of ViewerFile
did override this method, execution would jump to <code>viewer_file_set_property</code>
after having retrieved from the GParamSpec the <code>param_id</code> which had been
stored by <code>g_object_class_install_property()</code>.</p>
<p>Once the property has been set by the object’s <code>set_property</code> class method,
execution returns to <code>g_object_set_property()</code> which makes sure that the
“notify” signal is emitted on the object’s instance with the changed
property as parameter unless notifications were frozen by
<code>g_object_freeze_notify()</code>.</p>
<p><code>g_object_thaw_notify()</code> can be used to re-enable notification of property
modifications through the “notify” signal. It is important to remember that
even if properties are changed while property change notification is frozen,
the “notify” signal will be emitted once for each of these changed
properties as soon as the property change notification is thawed: no
property change is lost for the “notify” signal, although multiple
notifications for a single property are compressed. Signals can only be
delayed by the notification freezing&nbsp;mechanism.</p>
<p>It sounds like a tedious task to set up GValues every time when one wants to
modify a property. In practice one will rarely do this. The functions
<code>g_object_set_property()</code> and <code>g_object_get_property()</code> are meant to be used
by language bindings. For application there is an easier way and that is
described&nbsp;next.</p>
<h3 id="accessing-multiple-properties-at-once">Accessing multiple properties at once<a class="md-anchor" href="#accessing-multiple-properties-at-once" title="Permanent link"></a></h3>
<p>It is interesting to note that the <code>g_object_set()</code> and
<code>g_object_set_valist()</code> (variadic version) functions can be used to set
multiple properties at once. The client code shown above can then be
re-written&nbsp;as:</p>
<div class="codehilite"><pre><span></span><code><span class="n">ViewerFile</span><span class="w"> </span><span class="o">*</span><span class="n">file</span><span class="p">;</span>
<span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="cm">/* */</span><span class="p">;</span>
<span class="n">g_object_set</span><span class="w"> </span><span class="p">(</span><span class="n">G_OBJECT</span><span class="w"> </span><span class="p">(</span><span class="n">file</span><span class="p">),</span>
<span class="w">              </span><span class="s">"zoom-level"</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span>
<span class="w">              </span><span class="s">"filename"</span><span class="p">,</span><span class="w"> </span><span class="s">"~/some-file.txt"</span><span class="p">,</span><span class="w"> </span>
<span class="w">              </span><span class="nb">NULL</span><span class="p">);</span>
</code></pre></div>

<p>This saves us from managing the GValues that we were needing to handle when
using <code>g_object_set_property()</code>. The code above will trigger one notify
signal emission for each property&nbsp;modified.</p>
<p>Equivalent <code>_get</code> versions are also available: <code>g_object_get()</code> and
<code>g_object_get_valist()</code> (variadic version) can be used to get numerous
properties at&nbsp;once.</p>
<p>These high level functions have one drawback — they don’t provide a return
value. One should pay attention to the argument types and ranges when using
them. A known source of errors is to pass a different type from what the
property expects; for instance, passing an integer when the property expects
a floating point value and thus shifting all subsequent parameters by some
number of bytes. Also forgetting the terminating <span class="caps">NULL</span> will lead to undefined&nbsp;behaviour.</p>
<p>This explains how <code>g_object_new()</code>, <code>g_object_newv()</code> and
<code>g_object_new_valist()</code> work: they parse the user-provided variable number
of parameters and invoke <code>g_object_set()</code> on the parameters only after the
object has been successfully constructed. The “notify” signal will be
emitted for each property&nbsp;set.</p>
<h2 id="the-gobject-messaging-system">The GObject messaging system<a class="md-anchor" href="#the-gobject-messaging-system" title="Permanent link"></a></h2>
<h3 id="closures">Closures<a class="md-anchor" href="#closures" title="Permanent link"></a></h3>
<p>Closures are central to the concept of asynchronous signal delivery which is
widely used throughout <span class="caps">GTK</span> and <span class="caps">GNOME</span> applications. A closure is an
abstraction, a generic representation of a callback. It is a small structure
which contains three&nbsp;objects:</p>
<ul>
<li>a function pointer (the callback itself) whose prototype looks like:
  <code>return_type function_callback (... , gpointer user_data);</code></li>
<li>the <code>user_data</code> pointer which is passed to the callback upon invocation of
  the&nbsp;closure</li>
<li>a function pointer which represents the destructor of the closure:
  whenever the closure’s refcount reaches zero, this function will be called
  before the closure structure is&nbsp;freed</li>
</ul>
<p>The <code>GClosure</code> structure represents the common functionality of all closure
implementations: there exists a different closure implementation for each
separate runtime which wants to use the GObject type system. The GObject
library provides a simple GCClosure type which is a specific implementation
of closures to be used with C/C++&nbsp;callbacks.</p>
<p>A <code>GClosure</code> provides simple&nbsp;services:</p>
<ul>
<li>invocation (<code>g_closure_invoke()</code>): this is what closures were created for;
  they hide the details of callback invocation from the callback&nbsp;invoker.</li>
<li>notification: the closure notifies listeners of certain events such as
  closure invocation, closure invalidation and closure finalization.
  Listeners can be registered with <code>g_closure_add_finalize_notifier()</code>
  (finalization notification), <code>g_closure_add_invalidate_notifier()</code>
  (invalidation notification) and <code>g_closure_add_marshal_guards()</code>
  (invocation notification). There exist symmetric deregistration functions
  for finalization and invalidation events
  (<code>g_closure_remove_finalize_notifier()</code> and
  <code>g_closure_remove_invalidate_notifier()</code>) but not for the invocation&nbsp;process</li>
</ul>
<h4 id="c-closures">C Closures<a class="md-anchor" href="#c-closures" title="Permanent link"></a></h4>
<p>If you are using C or C++ to connect a callback to a given event, you will
either use simple <code>GCClosures</code> which have a pretty minimal <span class="caps">API</span> or the even
simpler <code>g_signal_connect()</code> functions (which will be presented a bit&nbsp;later).</p>
<p><code>g_cclosure_new()</code> will create a new closure which can invoke the
user-provided <code>callback_func</code> with the user-provided <code>user_data</code> as its last
parameter. When the closure is finalized (second stage of the destruction
process), it will invoke the <code>destroy_data</code> function if the user has
supplied&nbsp;one.</p>
<p><code>g_cclosure_new_swap()</code> will create a new closure which can invoke the
user-provided <code>callback_func</code> with the user-provided <code>user_data</code> as its
first parameter (instead of being the last parameter as with
<code>g_cclosure_new()</code>). When the closure is finalized (second stage of the
destruction process), it will invoke the <code>destroy_data</code> function if the user
has supplied&nbsp;one.</p>
<h4 id="non-c-closures-for-the-fearless">Non-C closures (for the fearless)<a class="md-anchor" href="#non-c-closures-for-the-fearless" title="Permanent link"></a></h4>
<p>As was explained above, closures hide the details of callback invocation. In
C, callback invocation is just like function invocation: it is a matter of
creating the correct stack frame for the called function and executing a
call assembly&nbsp;instruction.</p>
<p>C closure marshallers transform the array of GValues which represent the
parameters to the target function into a C-style function parameter list,
invoke the user-supplied C function with this new parameter list, get the
return value of the function, transform it into a GValue and return this
GValue to the marshaller&nbsp;caller.</p>
<p>A generic C closure marshaller is available as
<code>g_cclosure_marshal_generic()</code> which implements marshalling for all function
types using libffi. Custom marshallers for different types are not needed
apart from performance critical code where the libffi-based marshaller may
be too&nbsp;slow.</p>
<p>An example of a custom marshaller is given below, illustrating how GValues
can be converted to a C function call. The marshaller is for a C function
which takes an integer as its first parameter and returns <code>void</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="n">g_cclosure_marshal_VOID__INT</span><span class="w"> </span><span class="p">(</span><span class="n">GClosure</span><span class="w">     </span><span class="o">*</span><span class="n">closure</span><span class="p">,</span>
<span class="w">                              </span><span class="n">GValue</span><span class="w">       </span><span class="o">*</span><span class="n">return_value</span><span class="p">,</span>
<span class="w">                              </span><span class="n">guint</span><span class="w">         </span><span class="n">n_param_values</span><span class="p">,</span>
<span class="w">                              </span><span class="k">const</span><span class="w"> </span><span class="n">GValue</span><span class="w"> </span><span class="o">*</span><span class="n">param_values</span><span class="p">,</span>
<span class="w">                              </span><span class="n">gpointer</span><span class="w">      </span><span class="n">invocation_hint</span><span class="p">,</span>
<span class="w">                              </span><span class="n">gpointer</span><span class="w">      </span><span class="n">marshal_data</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">typedef</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">GMarshalFunc_VOID__INT</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">gpointer</span><span class="w">     </span><span class="n">data1</span><span class="p">,</span>
<span class="w">                                          </span><span class="n">gint</span><span class="w">         </span><span class="n">arg_1</span><span class="p">,</span>
<span class="w">                                          </span><span class="n">gpointer</span><span class="w">     </span><span class="n">data2</span><span class="p">);</span>
<span class="w">  </span><span class="k">register</span><span class="w"> </span><span class="n">GMarshalFunc_VOID__INT</span><span class="w"> </span><span class="n">callback</span><span class="p">;</span>
<span class="w">  </span><span class="k">register</span><span class="w"> </span><span class="n">GCClosure</span><span class="w"> </span><span class="o">*</span><span class="n">cc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">GCClosure</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">closure</span><span class="p">;</span>
<span class="w">  </span><span class="k">register</span><span class="w"> </span><span class="n">gpointer</span><span class="w"> </span><span class="n">data1</span><span class="p">,</span><span class="w"> </span><span class="n">data2</span><span class="p">;</span>

<span class="w">  </span><span class="n">g_return_if_fail</span><span class="w"> </span><span class="p">(</span><span class="n">n_param_values</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>

<span class="w">  </span><span class="n">data1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g_value_peek_pointer</span><span class="w"> </span><span class="p">(</span><span class="n">param_values</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="n">data2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">closure</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

<span class="w">  </span><span class="n">callback</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">GMarshalFunc_VOID__INT</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">marshal_data</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">marshal_data</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">cc</span><span class="o">-&gt;</span><span class="n">callback</span><span class="p">);</span>

<span class="w">  </span><span class="n">callback</span><span class="w"> </span><span class="p">(</span><span class="n">data1</span><span class="p">,</span>
<span class="w">            </span><span class="n">g_marshal_value_peek_int</span><span class="w"> </span><span class="p">(</span><span class="n">param_values</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span>
<span class="w">            </span><span class="n">data2</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>There exist other kinds of marshallers, for example there is a generic
Python marshaller which is used by all Python closures (a Python closure is
used to invoke a callback written in Python). This Python marshaller
transforms the input GValue list representing the function parameters into a
Python tuple which is the equivalent structure in&nbsp;Python.</p>
<h3 id="signals">Signals<a class="md-anchor" href="#signals" title="Permanent link"></a></h3>
<p>GObject’s signals have nothing to do with standard <span class="caps">UNIX</span> signals: they
connect arbitrary application-specific events with any number of listeners.
For example, in <span class="caps">GTK</span>, every user event (keystroke or mouse move) is received
from the windowing system and generates a <span class="caps">GTK</span> event in the form of a signal
emission on the widget object&nbsp;instance.</p>
<p>Each signal is registered in the type system together with the type on which
it can be emitted: users of the type are said to connect to the signal on a
given type instance when they register a closure to be invoked upon the
signal emission. Users can also emit the signal by themselves or stop the
emission of the signal from within one of the closures connected to the&nbsp;signal.</p>
<p>When a signal is emitted on a given type instance, all the closures
connected to this signal on this type instance will be invoked. All the
closures connected to such a signal represent callbacks whose signature
looks&nbsp;like:</p>
<div class="codehilite"><pre><span></span><code><span class="n">return_type</span>
<span class="nf">function_callback</span><span class="w"> </span><span class="p">(</span><span class="n">gpointer</span><span class="w"> </span><span class="n">instance</span><span class="p">,</span>
<span class="w">                   </span><span class="p">...,</span>
<span class="w">                   </span><span class="n">gpointer</span><span class="w"> </span><span class="n">user_data</span><span class="p">);</span>
</code></pre></div>

<h4 id="signal-registration">Signal registration<a class="md-anchor" href="#signal-registration" title="Permanent link"></a></h4>
<p>To register a new signal on an existing type, we can use any of
<code>g_signal_newv()</code>, <code>g_signal_new_valist()</code> or <code>g_signal_new()</code> functions:</p>
<div class="codehilite"><pre><span></span><code><span class="n">guint</span>
<span class="nf">g_signal_newv</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">gchar</span><span class="w">        </span><span class="o">*</span><span class="n">signal_name</span><span class="p">,</span>
<span class="w">               </span><span class="n">GType</span><span class="w">               </span><span class="n">itype</span><span class="p">,</span>
<span class="w">               </span><span class="n">GSignalFlags</span><span class="w">        </span><span class="n">signal_flags</span><span class="p">,</span>
<span class="w">               </span><span class="n">GClosure</span><span class="w">           </span><span class="o">*</span><span class="n">class_closure</span><span class="p">,</span>
<span class="w">               </span><span class="n">GSignalAccumulator</span><span class="w">  </span><span class="n">accumulator</span><span class="p">,</span>
<span class="w">               </span><span class="n">gpointer</span><span class="w">            </span><span class="n">accu_data</span><span class="p">,</span>
<span class="w">               </span><span class="n">GSignalCMarshaller</span><span class="w">  </span><span class="n">c_marshaller</span><span class="p">,</span>
<span class="w">               </span><span class="n">GType</span><span class="w">               </span><span class="n">return_type</span><span class="p">,</span>
<span class="w">               </span><span class="n">guint</span><span class="w">               </span><span class="n">n_params</span><span class="p">,</span>
<span class="w">               </span><span class="n">GType</span><span class="w">              </span><span class="o">*</span><span class="n">param_types</span><span class="p">);</span>
</code></pre></div>

<p>The number of parameters to these functions is a bit intimidating but they are relatively&nbsp;simple:</p>
<ul>
<li><code>signal_name</code>: is a string which can be used to uniquely identify a given&nbsp;signal</li>
<li><code>itype</code>: is the instance type on which this signal can be&nbsp;emitted</li>
<li><code>signal_flags</code>: partly defines the order in which closures which were
  connected to the signal are&nbsp;invoked</li>
<li><code>class_closure</code>: this is the default closure for the signal: if it is not
  <code>NULL</code> upon the signal emission, it will be invoked upon this emission of
  the signal. The moment where this closure is invoked compared to other
  closures connected to that signal depends partly on the <code>signal_flags</code></li>
<li><code>accumulator</code>: this is a function pointer which is invoked after each
  closure has been invoked. If it returns <code>FALSE</code>, signal emission is stopped.
  If it returns <code>TRUE</code>, signal emission proceeds normally. It is also used to
  compute the return value of the signal based on the return value of all
  the invoked closures. For example, an accumulator could ignore <code>NULL</code>
  returns from closures; or it could build a list of the values returned by
  the&nbsp;closures</li>
<li><code>accu_data</code>: this pointer will be passed down to each invocation of the
  accumulator during&nbsp;emission</li>
<li><code>c_marshaller</code>: this is the default C marshaller for any closure which is
  connected to this&nbsp;signal</li>
<li><code>return_type</code>: this is the type of the return value of the&nbsp;signal</li>
<li><code>n_params</code>: this is the number of parameters this signal&nbsp;takes</li>
<li><code>param_types</code>: this is an array of GTypes which indicate the type of each
  parameter of the signal. The length of this array is indicated by
  <code>n_params</code>.</li>
</ul>
<p>As you can see from the above definition, a signal is basically a
description of the closures which can be connected to this signal and a
description of the order in which the closures connected to this signal will
be&nbsp;invoked.</p>
<h4 id="signal-connection">Signal connection<a class="md-anchor" href="#signal-connection" title="Permanent link"></a></h4>
<p>If you want to connect to a signal with a closure, you have three&nbsp;possibilities:</p>
<ul>
<li>you can register a class closure at signal registration: this is a
  system-wide operation. i.e.: the class closure will be invoked during each
  emission of a given signal on any of the instances of the type which
  supports that&nbsp;signal</li>
<li>you can use <code>g_signal_override_class_closure()</code> which overrides the class
  closure of a given type. It is possible to call this function only on a
  derived type of the type on which the signal was registered. This function
  is of use only to language&nbsp;bindings</li>
<li>you can register a closure with the <code>g_signal_connect()</code> family of
  functions. This is an instance-specific operation: the closure will be
  invoked only during emission of a given signal on a given&nbsp;instance</li>
</ul>
<p>It is also possible to connect a different kind of callback on a given
signal: emission hooks are invoked whenever a given signal is emitted
whatever the instance on which it is emitted. Emission hooks are connected
with <code>g_signal_add_emission_hook()</code> and removed with
<code>g_signal_remove_emission_hook()</code>.</p>
<h4 id="signal-emission">Signal emission<a class="md-anchor" href="#signal-emission" title="Permanent link"></a></h4>
<p>Signal emission is done through the use of the <code>g_signal_emit()</code> family of&nbsp;functions.</p>
<div class="codehilite"><pre><span></span><code><span class="kt">void</span>
<span class="nf">g_signal_emitv</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">GValue</span><span class="w">  </span><span class="n">instance_and_params</span><span class="p">[],</span>
<span class="w">                </span><span class="n">guint</span><span class="w">         </span><span class="n">signal_id</span><span class="p">,</span>
<span class="w">                </span><span class="n">GQuark</span><span class="w">        </span><span class="n">detail</span><span class="p">,</span>
<span class="w">                </span><span class="n">GValue</span><span class="w">       </span><span class="o">*</span><span class="n">return_value</span><span class="p">);</span>
</code></pre></div>

<ul>
<li>the <code>instance_and_params</code> array of GValues contains the list of input
  parameters to the signal. The first element of the array is the instance
  pointer on which to invoke the signal. The following elements of the array
  contain the list of parameters to the&nbsp;signal</li>
<li><code>signal_id</code> identifies the signal to&nbsp;invoke</li>
<li><code>detail</code> identifies the specific detail of the signal to invoke. A detail
  is a kind of magic token/argument which is passed around during signal
  emission and which is used by closures connected to the signal to filter
  out unwanted signal emissions. In most cases, you can safely set this
  value to zero. See the section called “The detail argument” for more
  information about this&nbsp;parameter</li>
<li><code>return_value</code> holds the return value of the last closure invoked during
  emission if no accumulator was specified. If an accumulator was specified
  during signal creation, this accumulator is used to calculate the return
  value as a function of the return values of all the closures invoked
  during emission. If no closure is invoked during emission, the
  <code>return_value</code> is nonetheless initialized to zero/<code>NULL</code></li>
</ul>
<p>Signal emission can be decomposed in 6&nbsp;steps:</p>
<ol>
<li><code>RUN_FIRST</code>: if the <code>G_SIGNAL_RUN_FIRST</code> flag was used during signal
   registration and if there exists a class closure for this signal, the
   class closure is&nbsp;invoked.</li>
<li><code>EMISSION_HOOK</code>: if any emission hook was added to the signal, they are
   invoked from first to last added. Accumulate return&nbsp;values.</li>
<li><code>HANDLER_RUN_FIRST</code>: if any closure were connected with the
   <code>g_signal_connect()</code> family of functions, and if they are not blocked
   (with the <code>g_signal_handler_block()</code> family of functions) they are run
   here, from first to last&nbsp;connected.</li>
<li><code>RUN_LAST</code>: if the <code>G_SIGNAL_RUN_LAST</code> flag was set during registration
   and if a class closure was set, it is invoked&nbsp;here.</li>
<li><code>HANDLER_RUN_LAST</code>: if any closure were connected with the
   <code>g_signal_connect_after()</code> family of functions, if they were not invoked
   during <code>HANDLER_RUN_FIRST</code> and if they are not blocked, they are run
   here, from first to last&nbsp;connected.</li>
<li><code>RUN_CLEANUP</code>: if the <code>G_SIGNAL_RUN_CLEANUP</code> flag was set during
   registration and if a class closure was set, it is invoked here. Signal
   emission is completed&nbsp;here.</li>
</ol>
<p>If, at any point during the emission (except in the <code>RUN_CLEANUP</code> or
<code>EMISSION_HOOK</code> states), one of the closures stops the signal emission with
<code>g_signal_stop_emission()</code>, the emission jumps to the <code>RUN_CLEANUP</code> state.</p>
<p>If, at any point during emission, one of the closures or emission hook emits
the same signal on the same instance, emission is restarted from the
<code>RUN_FIRST</code> state.</p>
<p>The accumulator function is invoked in all states, after invocation of each
closure (except in <code>RUN_EMISSION_HOOK</code> and <code>RUN_CLEANUP</code>). It accumulates
the closure return value into the signal return value and returns <code>TRUE</code> or
<code>FALSE</code>.  If, at any point, it does not return <code>TRUE</code>, emission jumps to
<code>RUN_CLEANUP</code> state.</p>
<p>If no accumulator function was provided, the value returned by the last
handler run will be returned by <code>g_signal_emit()</code>.</p>
<h4 id="the-detail-argument">The detail argument<a class="md-anchor" href="#the-detail-argument" title="Permanent link"></a></h4>
<p>All the functions related to signal emission or signal connection have a
parameter named the detail. Sometimes, this parameter is hidden by the <span class="caps">API</span>
but it is always there, in one form or&nbsp;another.</p>
<p>Of the three main connection functions, only one has an explicit detail
parameter as a GQuark: <code>g_signal_connect_closure_by_id()</code>.</p>
<p>The two other functions, <code>g_signal_connect_closure()</code> and
<code>g_signal_connect_data()</code> hide the detail parameter in the signal name
identification. Their <code>detailed_signal</code> parameter is a string which
identifies the name of the signal to connect to. The format of this string
should match <code>signal_name::detail_name</code>. For example, connecting to the
signal named <code>notify::cursor_position</code> will actually connect to the signal
named <code>notify</code> with the <code>cursor_position</code> detail. Internally, the detail
string is transformed to a GQuark if it is&nbsp;present.</p>
<p>Of the four main signal emission functions, one hides it in its signal name
parameter: <code>g_signal_emit_by_name()</code>. The other three have an explicit
detail parameter as a GQuark again: <code>g_signal_emit()</code>, <code>g_signal_emitv()</code>
and <code>g_signal_emit_valist()</code>.</p>
<p>If a detail is provided by the user to the emission function, it is used
during emission to match against the closures which also provide a detail.
If a closure’s detail does not match the detail provided by the user, it
will not be invoked (even though it is connected to a signal which is being&nbsp;emitted).</p>
<p>This completely optional filtering mechanism is mainly used as an
optimization for signals which are often emitted for many different reasons:
the clients can filter out which events they are interested in before the
closure’s marshalling code runs. For example, this is used extensively by
the notify signal of GObject: whenever a property is modified on a GObject,
instead of just emitting the notify signal, GObject associates as a detail
to this signal emission the name of the property modified. This allows
clients who wish to be notified of changes to only one property to filter
most events before receiving&nbsp;them.</p>
<p>As a simple rule, users can and should set the detail parameter to zero:
this will disable completely this optional filtering for that&nbsp;signal.</p>
    </div>
  </section>
</section>


    



    <section id="search" class="content hidden"></section>

    <footer>
    
    </footer>
  </div>



</body><!-- Mirrored from docs.gtk.org/gobject/concepts.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 16 Dec 2024 17:55:03 GMT --></html>