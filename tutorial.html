<!--
SPDX-FileCopyrightText: GLib Development Team

SPDX-License-Identifier: LGPL-2.1-or-later
--><!DOCTYPE html><html lang="en"><!-- Mirrored from docs.gtk.org/gobject/tutorial.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 16 Dec 2024 17:55:03 GMT --><!-- Added by HTTrack --><head><meta http-equiv="content-type" content="text/html;charset=utf-8"><!-- /Added by HTTrack -->

  <title>GObject – 2.0: GObject Tutorial</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <meta charset="utf-8">

  
  <meta property="og:type" content="website">

  

  
  <meta property="og:title" content="GObject: GObject Tutorial">
  <meta property="og:description" content="Reference for GObject-2.0: GObject Tutorial">
  <meta name="twitter:title" content="GObject: GObject Tutorial">
  <meta name="twitter:description" content="Reference for GObject-2.0: GObject Tutorial">


  
  <meta name="twitter:card" content="summary">

  
  
  
  <link rel="search" type="application/opensearchdescription+xml" title="GObject" href="opensearch.xml">
  
  

  <link rel="stylesheet" href="style.css" type="text/css">

  

  
  <script src="urlmap.js"></script>
  
  
  <script src="fzy.js"></script>
  <script src="search.js"></script>
  
  <script src="main.js"></script>

  
</head>

<body>
  <div id="body-wrapper" tabindex="-1">

    

    

    
<section id="main" class="content">
  
  <h4 id="title" style="display:flex;">
    GObject Tutorial
    <a href="#title" class="anchor"></a>
    
  </h4>
  
  <section>
    <div class="docblock">
    <h1 id="gobject-tutorial">GObject Tutorial<a class="md-anchor" href="#gobject-tutorial" title="Permanent link"></a></h1>
<h2 id="how-to-define-and-implement-a-new-gobject">How to define and implement a new GObject<a class="md-anchor" href="#how-to-define-and-implement-a-new-gobject" title="Permanent link"></a></h2>
<p>This document focuses on the implementation of a subtype of GObject, for
example to create a custom class hierarchy, or to subclass a <span class="caps">GTK</span>&nbsp;widget.</p>
<p>Throughout the chapter, a running example of a file viewer program is used,
which has a <code>ViewerFile</code> class to represent a single file being viewed, and
various derived classes for different types of files with special
functionality, such as audio files. The example application also supports
editing files (for example, to tweak a photo being viewed), using a
<code>ViewerEditable</code> interface.</p>
<h3 id="boilerplate-header-code">Boilerplate header code<a class="md-anchor" href="#boilerplate-header-code" title="Permanent link"></a></h3>
<p>The first step before writing the code for your GObject is to write the
type’s header which contains the needed type, function and macro
definitions. Each of these elements is nothing but a convention which is
followed by almost all users of GObject, and has been refined over multiple
years of experience developing GObject-based code. If you are writing a
library, it is particularly important for you to adhere closely to these
conventions; users of your library will assume that you have. Even if not
writing a library, it will help other people who want to work on your&nbsp;project.</p>
<p>Pick a name convention for your headers and source code and stick to&nbsp;it:</p>
<ul>
<li>use a dash to separate the prefix from the typename: <code>viewer-file.h</code> and
  <code>viewer-file.c</code> (this is the convention used by most <span class="caps">GNOME</span> libraries and&nbsp;applications)</li>
<li>use an underscore to separate the prefix from the typename:
  <code>viewer_file.h</code> and <code>viewer_file.c</code></li>
<li>do not separate the prefix from the typename: <code>viewerfile.h</code> and
  <code>viewerfile.c</code> (this is the convention used by <span class="caps">GTK</span>)</li>
</ul>
<p>Some people like the first two solutions better: it makes reading file names
easier for those with poor&nbsp;eyesight.</p>
<p>The basic conventions for any header which exposes a GType are described in
the section of the Type system introduction called
<a href="concepts.html#conventions">“Conventions”</a>.</p>
<p>If you want to declare a type named “file” in the namespace “viewer”, name
the type instance <code>ViewerFile</code> and its class <code>ViewerFileClass</code> (names are
case sensitive). The recommended method of declaring a type differs based on
whether the type is final or&nbsp;derivable.</p>
<p>Final types cannot be subclassed further, and should be the default choice
for new types—changing a final type to be derivable is always a change that
will be compatible with existing uses of the code, but the converse will
often cause problems. Final types are declared using the
<code>G_DECLARE_FINAL_TYPE</code> macro, and require a structure to hold the instance
data to be declared in the source code (not the header&nbsp;file).</p>
<div class="codehilite"><pre><span></span><code><span class="cm">/*</span>
<span class="cm"> * Copyright/Licensing information.</span>
<span class="cm"> */</span>

<span class="cm">/* inclusion guard */</span>
<span class="cp">#pragma once</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;glib-object.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Potentially, include other headers on which this header depends.</span>
<span class="cm"> */</span>

<span class="n">G_BEGIN_DECLS</span>

<span class="cm">/*</span>
<span class="cm"> * Type declaration.</span>
<span class="cm"> */</span>
<span class="cp">#define VIEWER_TYPE_FILE viewer_file_get_type()</span>
<span class="n">G_DECLARE_FINAL_TYPE</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerFile</span><span class="p">,</span><span class="w"> </span><span class="n">viewer_file</span><span class="p">,</span><span class="w"> </span><span class="n">VIEWER</span><span class="p">,</span><span class="w"> </span><span class="kt">FILE</span><span class="p">,</span><span class="w"> </span><span class="n">GObject</span><span class="p">)</span>

<span class="cm">/*</span>
<span class="cm"> * Method definitions.</span>
<span class="cm"> */</span>
<span class="n">ViewerFile</span><span class="w"> </span><span class="o">*</span><span class="n">viewer_file_new</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="n">G_END_DECLS</span>
</code></pre></div>

<p>Derivable types can be subclassed further, and their class and instance
structures form part of the public <span class="caps">API</span> which must not be changed if <span class="caps">API</span>
stability is cared about. They are declared using the
<code>G_DECLARE_DERIVABLE_TYPE</code> macro:</p>
<div class="codehilite"><pre><span></span><code><span class="cm">/*</span>
<span class="cm"> * Copyright/Licensing information.</span>
<span class="cm"> */</span>

<span class="cm">/* inclusion guard */</span>
<span class="cp">#pragma once</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;glib-object.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Potentially, include other headers on which this header depends.</span>
<span class="cm"> */</span>

<span class="n">G_BEGIN_DECLS</span>

<span class="cm">/*</span>
<span class="cm"> * Type declaration.</span>
<span class="cm"> */</span>
<span class="cp">#define VIEWER_TYPE_FILE viewer_file_get_type()</span>
<span class="n">G_DECLARE_DERIVABLE_TYPE</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerFile</span><span class="p">,</span><span class="w"> </span><span class="n">viewer_file</span><span class="p">,</span><span class="w"> </span><span class="n">VIEWER</span><span class="p">,</span><span class="w"> </span><span class="kt">FILE</span><span class="p">,</span><span class="w"> </span><span class="n">GObject</span><span class="p">)</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">_ViewerFileClass</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">GObjectClass</span><span class="w"> </span><span class="n">parent_class</span><span class="p">;</span>

<span class="w">  </span><span class="cm">/* Class virtual function fields. */</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="w"> </span><span class="n">open</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerFile</span><span class="w">  </span><span class="o">*</span><span class="n">file</span><span class="p">,</span>
<span class="w">                 </span><span class="n">GError</span><span class="w">     </span><span class="o">**</span><span class="n">error</span><span class="p">);</span>

<span class="w">  </span><span class="cm">/* Padding to allow adding up to 12 new virtual functions without</span>
<span class="cm">   * breaking ABI. */</span>
<span class="w">  </span><span class="n">gpointer</span><span class="w"> </span><span class="n">padding</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Method definitions.</span>
<span class="cm"> */</span>
<span class="n">ViewerFile</span><span class="w"> </span><span class="o">*</span><span class="nf">viewer_file_new</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="n">G_END_DECLS</span>
</code></pre></div>

<p>The convention for header includes is to add the minimum number of
<code>#include</code> directives to the top of your headers needed to compile that
header. This allows client code to simply <code>#include "viewer-file.h"</code>,
without needing to know the prerequisites for <code>viewer-file.h</code>.</p>
<h3 id="boilerplate-code">Boilerplate code<a class="md-anchor" href="#boilerplate-code" title="Permanent link"></a></h3>
<p>In your code, the first step is to <code>#include</code> the needed&nbsp;headers:</p>
<div class="codehilite"><pre><span></span><code><span class="cm">/*</span>
<span class="cm"> * Copyright/Licensing information</span>
<span class="cm"> */</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">"viewer-file.h"</span>

<span class="cm">/* Private structure definition. */</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">filename</span><span class="p">;</span>

<span class="w">  </span><span class="cm">/* other private fields */</span>
<span class="p">}</span><span class="w"> </span><span class="n">ViewerFilePrivate</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * forward definitions</span>
<span class="cm"> */</span>
</code></pre></div>

<p>If the class is being declared as final using <code>G_DECLARE_FINAL_TYPE</code>, its instance structure should be defined in the C&nbsp;file:</p>
<div class="codehilite"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">_ViewerFile</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">GObject</span><span class="w"> </span><span class="n">parent_instance</span><span class="p">;</span>

<span class="w">  </span><span class="cm">/* Other members, including private data. */</span>
<span class="p">};</span>
</code></pre></div>

<p>Call the <code>G_DEFINE_TYPE</code> macro (or <code>G_DEFINE_TYPE_WITH_PRIVATE</code> if your
class needs private data—final types do not need private data) using the
name of the type, the prefix of the functions and the parent GType to reduce
the amount of boilerplate needed. This macro&nbsp;will:</p>
<ul>
<li>implement the <code>viewer_file_get_type</code> function</li>
<li>define a parent class pointer accessible from the whole <code>.c</code> file</li>
<li>add private instance data to the type (if using <code>G_DEFINE_TYPE_WITH_PRIVATE</code>)</li>
</ul>
<p>If the class has been declared as final using <code>G_DECLARE_FINAL_TYPE</code> private
data should be placed in the instance structure, <code>ViewerFile</code>, and
<code>G_DEFINE_TYPE</code> should be used instead of <code>G_DEFINE_TYPE_WITH_PRIVATE</code>. The
instance structure for a final class is not exposed publicly, and is not
embedded in the instance structures of any derived classes (because the
class is final); so its size can vary without causing incompatibilities for
code which uses the class. Conversely, private data for derivable classes
must be included in a private structure, and <code>G_DEFINE_TYPE_WITH_PRIVATE</code>
must be&nbsp;used.</p>
<div class="codehilite"><pre><span></span><code><span class="n">G_DEFINE_TYPE</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerFile</span><span class="p">,</span><span class="w"> </span><span class="n">viewer_file</span><span class="p">,</span><span class="w"> </span><span class="n">G_TYPE_OBJECT</span><span class="p">)</span>
</code></pre></div>

<p>or</p>
<div class="codehilite"><pre><span></span><code><span class="n">G_DEFINE_TYPE_WITH_PRIVATE</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerFile</span><span class="p">,</span><span class="w"> </span><span class="n">viewer_file</span><span class="p">,</span><span class="w"> </span><span class="n">G_TYPE_OBJECT</span><span class="p">)</span>
</code></pre></div>

<p>It is also possible to use the <code>G_DEFINE_TYPE_WITH_CODE</code> macro to control
the <code>get_type</code> function implementation — for instance, to add a call to the
<code>G_IMPLEMENT_INTERFACE</code> macro to implement an&nbsp;interface.</p>
<h3 id="object-construction">Object construction<a class="md-anchor" href="#object-construction" title="Permanent link"></a></h3>
<p>People often get confused when trying to construct their GObjects because of
the sheer number of different ways to hook into the objects’s construction
process: it is difficult to figure which is the correct, recommended&nbsp;way.</p>
<p>The <a href="concepts.html#object-instantiation">documentation on object
instantiation</a> shows what user-provided
functions are invoked during object instantiation and in which order they
are invoked. A user looking for the equivalent of the simple C++ constructor
function should use the <code>instance_init</code> method. It will be invoked after all
the parents’ <code>instance_init</code> functions have been invoked. It cannot take
arbitrary construction parameters (as in C++) but if your object needs
arbitrary parameters to complete initialization, you can use construction&nbsp;properties.</p>
<p>Construction properties will be set only after all <code>instance_init</code> functions have run. No object reference will be returned to the client of <code>g_object_new()</code> until all the construction properties have been&nbsp;set.</p>
<p>It is important to note that object construction cannot ever fail. If you
require a fallible GObject construction, you can use the <code>GInitable</code> and
<code>GAsyncInitable</code> interfaces provided by the <span class="caps">GIO</span>&nbsp;library.</p>
<p>You should write the following code&nbsp;first:</p>
<div class="codehilite"><pre><span></span><code><span class="n">G_DEFINE_TYPE_WITH_PRIVATE</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerFile</span><span class="p">,</span><span class="w"> </span><span class="n">viewer_file</span><span class="p">,</span><span class="w"> </span><span class="n">G_TYPE_OBJECT</span><span class="p">)</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="n">viewer_file_class_init</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerFileClass</span><span class="w"> </span><span class="o">*</span><span class="n">klass</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="n">viewer_file_init</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerFile</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">ViewerFilePrivate</span><span class="w"> </span><span class="o">*</span><span class="n">priv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">viewer_file_get_instance_private</span><span class="w"> </span><span class="p">(</span><span class="n">self</span><span class="p">);</span>

<span class="w">  </span><span class="cm">/* initialize all public and private members to reasonable default values.</span>
<span class="cm">   * They are all automatically initialized to 0 to begin with. */</span>
<span class="p">}</span>
</code></pre></div>

<p>If you need special construction properties (with <code>G_PARAM_CONSTRUCT_ONLY</code>
set), install the properties in the <code>class_init()</code> function, override the
<code>set_property()</code> and <code>get_property()</code> methods of the GObject class, and
implement them as described by the section called <a href="concepts.html#object-properties">“Object
properties”</a>.</p>
<p>Property identifiers must start from 1, as 0 is reserved for internal use by&nbsp;GObject.</p>
<div class="codehilite"><pre><span></span><code><span class="k">enum</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">PROP_FILENAME</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">  </span><span class="n">PROP_ZOOM_LEVEL</span><span class="p">,</span>
<span class="w">  </span><span class="n">N_PROPERTIES</span>
<span class="p">};</span>

<span class="k">static</span><span class="w"> </span><span class="n">GParamSpec</span><span class="w"> </span><span class="o">*</span><span class="n">obj_properties</span><span class="p">[</span><span class="n">N_PROPERTIES</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="p">};</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">viewer_file_class_init</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerFileClass</span><span class="w"> </span><span class="o">*</span><span class="n">klass</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">GObjectClass</span><span class="w"> </span><span class="o">*</span><span class="n">object_class</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">G_OBJECT_CLASS</span><span class="w"> </span><span class="p">(</span><span class="n">klass</span><span class="p">);</span>

<span class="w">  </span><span class="n">object_class</span><span class="o">-&gt;</span><span class="n">set_property</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">viewer_file_set_property</span><span class="p">;</span>
<span class="w">  </span><span class="n">object_class</span><span class="o">-&gt;</span><span class="n">get_property</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">viewer_file_get_property</span><span class="p">;</span>

<span class="w">  </span><span class="n">obj_properties</span><span class="p">[</span><span class="n">PROP_FILENAME</span><span class="p">]</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="n">g_param_spec_string</span><span class="w"> </span><span class="p">(</span><span class="s">"filename"</span><span class="p">,</span>
<span class="w">                         </span><span class="s">"Filename"</span><span class="p">,</span>
<span class="w">                         </span><span class="s">"Name of the file to load and display from."</span><span class="p">,</span>
<span class="w">                         </span><span class="nb">NULL</span><span class="w">  </span><span class="cm">/* default value */</span><span class="p">,</span>
<span class="w">                         </span><span class="n">G_PARAM_CONSTRUCT_ONLY</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">G_PARAM_READWRITE</span><span class="p">);</span>

<span class="w">  </span><span class="n">obj_properties</span><span class="p">[</span><span class="n">PROP_ZOOM_LEVEL</span><span class="p">]</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="n">g_param_spec_uint</span><span class="w"> </span><span class="p">(</span><span class="s">"zoom-level"</span><span class="p">,</span>
<span class="w">                       </span><span class="s">"Zoom level"</span><span class="p">,</span>
<span class="w">                       </span><span class="s">"Zoom level to view the file at."</span><span class="p">,</span>
<span class="w">                       </span><span class="mi">0</span><span class="w">  </span><span class="cm">/* minimum value */</span><span class="p">,</span>
<span class="w">                       </span><span class="mi">10</span><span class="w"> </span><span class="cm">/* maximum value */</span><span class="p">,</span>
<span class="w">                       </span><span class="mi">2</span><span class="w">  </span><span class="cm">/* default value */</span><span class="p">,</span>
<span class="w">                       </span><span class="n">G_PARAM_READWRITE</span><span class="p">);</span>

<span class="w">  </span><span class="n">g_object_class_install_properties</span><span class="w"> </span><span class="p">(</span><span class="n">object_class</span><span class="p">,</span>
<span class="w">                                     </span><span class="n">N_PROPERTIES</span><span class="p">,</span>
<span class="w">                                     </span><span class="n">obj_properties</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>If you need this, make sure you can build and run code similar to the code
shown above. Also, make sure your construct properties can be set without
side effects during&nbsp;construction.</p>
<p>Some people sometimes need to complete the initialization of an instance of
a type only after the properties passed to the constructors have been set.
This is possible through the use of the <code>constructor()</code> class method as
described in the section called “Object instantiation” or, more simply,
using the <code>constructed()</code> class method. Note that the <code>constructed()</code> virtual
function will only be invoked after the properties marked as
<code>G_PARAM_CONSTRUCT_ONLY</code> or <code>G_PARAM_CONSTRUCT</code> have been consumed, but before
the regular properties passed to <code>g_object_new()</code> have been&nbsp;set.</p>
<h3 id="object-destruction">Object destruction<a class="md-anchor" href="#object-destruction" title="Permanent link"></a></h3>
<p>Again, it is often difficult to figure out which mechanism to use to hook
into the object’s destruction process: when the last <code>g_object_unref()</code> function
call is made, a lot of things happen as described in <a href="concepts.html#object-memory-management">the “Object memory
management” section</a> of the&nbsp;documentation.</p>
<p>The destruction process of your object is in two phases: dispose and
finalize. This split is necessary to handle potential cycles due to the
nature of the reference counting mechanism used by GObject, as well as
dealing with temporary revival of instances in case of signal emission
during the destruction&nbsp;sequence.</p>
<div class="codehilite"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">_ViewerFilePrivate</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">gchar</span><span class="w"> </span><span class="o">*</span><span class="n">filename</span><span class="p">;</span>
<span class="w">  </span><span class="n">guint</span><span class="w"> </span><span class="n">zoom_level</span><span class="p">;</span>

<span class="w">  </span><span class="n">GInputStream</span><span class="w"> </span><span class="o">*</span><span class="n">input_stream</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">G_DEFINE_TYPE_WITH_PRIVATE</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerFile</span><span class="p">,</span><span class="w"> </span><span class="n">viewer_file</span><span class="p">,</span><span class="w"> </span><span class="n">G_TYPE_OBJECT</span><span class="p">)</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="n">viewer_file_dispose</span><span class="w"> </span><span class="p">(</span><span class="n">GObject</span><span class="w"> </span><span class="o">*</span><span class="n">gobject</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">ViewerFilePrivate</span><span class="w"> </span><span class="o">*</span><span class="n">priv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">viewer_file_get_instance_private</span><span class="w"> </span><span class="p">(</span><span class="n">VIEWER_FILE</span><span class="w"> </span><span class="p">(</span><span class="n">gobject</span><span class="p">));</span>

<span class="w">  </span><span class="cm">/* In dispose(), you are supposed to free all types referenced from this</span>
<span class="cm">   * object which might themselves hold a reference to self. Generally,</span>
<span class="cm">   * the most simple solution is to unref all members on which you own a</span>
<span class="cm">   * reference.</span>
<span class="cm">   */</span>

<span class="w">  </span><span class="cm">/* dispose() might be called multiple times, so we must guard against</span>
<span class="cm">   * calling g_object_unref() on an invalid GObject by setting the member</span>
<span class="cm">   * NULL; g_clear_object() does this for us.</span>
<span class="cm">   */</span>
<span class="w">  </span><span class="n">g_clear_object</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">input_stream</span><span class="p">);</span>

<span class="w">  </span><span class="cm">/* Always chain up to the parent class; there is no need to check if</span>
<span class="cm">   * the parent class implements the dispose() virtual function: it is</span>
<span class="cm">   * always guaranteed to do so</span>
<span class="cm">   */</span>
<span class="w">  </span><span class="n">G_OBJECT_CLASS</span><span class="w"> </span><span class="p">(</span><span class="n">viewer_file_parent_class</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dispose</span><span class="w"> </span><span class="p">(</span><span class="n">gobject</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="n">viewer_file_finalize</span><span class="w"> </span><span class="p">(</span><span class="n">GObject</span><span class="w"> </span><span class="o">*</span><span class="n">gobject</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">ViewerFilePrivate</span><span class="w"> </span><span class="o">*</span><span class="n">priv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">viewer_file_get_instance_private</span><span class="w"> </span><span class="p">(</span><span class="n">VIEWER_FILE</span><span class="w"> </span><span class="p">(</span><span class="n">gobject</span><span class="p">));</span>

<span class="w">  </span><span class="n">g_free</span><span class="w"> </span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">filename</span><span class="p">);</span>

<span class="w">  </span><span class="cm">/* Always chain up to the parent class; as with dispose(), finalize()</span>
<span class="cm">   * is guaranteed to exist on the parent's class virtual function table</span>
<span class="cm">   */</span>
<span class="w">  </span><span class="n">G_OBJECT_CLASS</span><span class="w"> </span><span class="p">(</span><span class="n">viewer_file_parent_class</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">finalize</span><span class="w"> </span><span class="p">(</span><span class="n">gobject</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="n">viewer_file_class_init</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerFileClass</span><span class="w"> </span><span class="o">*</span><span class="n">klass</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">GObjectClass</span><span class="w"> </span><span class="o">*</span><span class="n">object_class</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">G_OBJECT_CLASS</span><span class="w"> </span><span class="p">(</span><span class="n">klass</span><span class="p">);</span>

<span class="w">  </span><span class="n">object_class</span><span class="o">-&gt;</span><span class="n">dispose</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">viewer_file_dispose</span><span class="p">;</span>
<span class="w">  </span><span class="n">object_class</span><span class="o">-&gt;</span><span class="n">finalize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">viewer_file_finalize</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="n">viewer_file_init</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerFile</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">);</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">ViewerFilePrivate</span><span class="w"> </span><span class="o">*</span><span class="n">priv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">viewer_file_get_instance_private</span><span class="w"> </span><span class="p">(</span><span class="n">self</span><span class="p">);</span>

<span class="w">  </span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">input_stream</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g_object_new</span><span class="w"> </span><span class="p">(</span><span class="n">VIEWER_TYPE_INPUT_STREAM</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
<span class="w">  </span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">filename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="cm">/* would be set as a property */</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>It is possible that object methods might be invoked after dispose is run and
before finalize runs. GObject does not consider this to be a program error:
you must gracefully detect this and neither crash nor warn the user, by
having a disposed instance revert to an inert&nbsp;state.</p>
<h3 id="object-methods">Object methods<a class="md-anchor" href="#object-methods" title="Permanent link"></a></h3>
<p>Just as with C++, there are many different ways to define object methods and
extend them: the following list and sections draw on C++ vocabulary.
(Readers are expected to know basic C++ concepts. Those who have not had to
write C++ code recently can refer to a <a href="http://www.cplusplus.com/doc/tutorial/">C++
tutorial</a> to refresh their&nbsp;memories.)</p>
<ul>
<li>non-virtual public&nbsp;methods,</li>
<li>virtual public methods&nbsp;and</li>
<li>virtual private&nbsp;methods</li>
<li>non-virtual private&nbsp;methods</li>
</ul>
<h4 id="non-virtual-methods">Non-Virtual Methods<a class="md-anchor" href="#non-virtual-methods" title="Permanent link"></a></h4>
<p>These are the simplest, providing a simple method which acts on the object.
Provide a function prototype in the header and an implementation of that
prototype in the source&nbsp;file.</p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* declaration in the header. */</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">viewer_file_open</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerFile</span><span class="w">  </span><span class="o">*</span><span class="n">self</span><span class="p">,</span>
<span class="w">                       </span><span class="n">GError</span><span class="w">     </span><span class="o">**</span><span class="n">error</span><span class="p">);</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="cm">/* implementation in the source file */</span>
<span class="kt">void</span>
<span class="nf">viewer_file_open</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerFile</span><span class="w">  </span><span class="o">*</span><span class="n">self</span><span class="p">,</span>
<span class="w">                  </span><span class="n">GError</span><span class="w">     </span><span class="o">**</span><span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">g_return_if_fail</span><span class="w"> </span><span class="p">(</span><span class="n">VIEWER_IS_FILE</span><span class="w"> </span><span class="p">(</span><span class="n">self</span><span class="p">));</span>
<span class="w">  </span><span class="n">g_return_if_fail</span><span class="w"> </span><span class="p">(</span><span class="n">error</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">*</span><span class="n">error</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>

<span class="w">  </span><span class="cm">/* do stuff here. */</span>
<span class="p">}</span>
</code></pre></div>

<h4 id="virtual-public-methods">Virtual public methods<a class="md-anchor" href="#virtual-public-methods" title="Permanent link"></a></h4>
<p>This is the preferred way to create GObjects with overridable&nbsp;methods:</p>
<ul>
<li>define the common method and its virtual function in the class structure
  in the public&nbsp;header</li>
<li>define the common method in the header file and implement it in the source&nbsp;file</li>
<li>implement a base version of the virtual function in the source file and
  initialize the virtual function pointer to this implementation in the
  object’s <code>class_init</code> function; or leave it as <code>NULL</code> for a ‘pure virtual’
  method which must be overridden by derived&nbsp;classes</li>
<li>re-implement the virtual function in each derived class which needs to
  override&nbsp;it</li>
</ul>
<p>Note that virtual functions can only be defined if the class is derivable,
declared using <code>G_DECLARE_DERIVABLE_TYPE</code> so the class structure can be&nbsp;defined.</p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* declaration in viewer-file.h. */</span>
<span class="cp">#define VIEWER_TYPE_FILE viewer_file_get_type ()</span>
<span class="n">G_DECLARE_DERIVABLE_TYPE</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerFile</span><span class="p">,</span><span class="w"> </span><span class="n">viewer_file</span><span class="p">,</span><span class="w"> </span><span class="n">VIEWER</span><span class="p">,</span><span class="w"> </span><span class="kt">FILE</span><span class="p">,</span><span class="w"> </span><span class="n">GObject</span><span class="p">)</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">_ViewerFileClass</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">GObjectClass</span><span class="w"> </span><span class="n">parent_class</span><span class="p">;</span>

<span class="w">  </span><span class="cm">/* stuff */</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">open</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerFile</span><span class="w">  </span><span class="o">*</span><span class="n">self</span><span class="p">,</span>
<span class="w">                </span><span class="n">GError</span><span class="w">     </span><span class="o">**</span><span class="n">error</span><span class="p">);</span>

<span class="w">  </span><span class="cm">/* Padding to allow adding up to 12 new virtual functions without</span>
<span class="cm">   * breaking ABI. */</span>
<span class="w">  </span><span class="n">gpointer</span><span class="w"> </span><span class="n">padding</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
<span class="p">};</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">viewer_file_open</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerFile</span><span class="w">  </span><span class="o">*</span><span class="n">self</span><span class="p">,</span>
<span class="w">                       </span><span class="n">GError</span><span class="w">     </span><span class="o">**</span><span class="n">error</span><span class="p">);</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="cm">/* implementation in viewer-file.c */</span>
<span class="kt">void</span>
<span class="nf">viewer_file_open</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerFile</span><span class="w">  </span><span class="o">*</span><span class="n">self</span><span class="p">,</span>
<span class="w">                  </span><span class="n">GError</span><span class="w">     </span><span class="o">**</span><span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">ViewerFileClass</span><span class="w"> </span><span class="o">*</span><span class="n">klass</span><span class="p">;</span>

<span class="w">  </span><span class="n">g_return_if_fail</span><span class="w"> </span><span class="p">(</span><span class="n">VIEWER_IS_FILE</span><span class="w"> </span><span class="p">(</span><span class="n">self</span><span class="p">));</span>
<span class="w">  </span><span class="n">g_return_if_fail</span><span class="w"> </span><span class="p">(</span><span class="n">error</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">*</span><span class="n">error</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>

<span class="w">  </span><span class="n">klass</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VIEWER_FILE_GET_CLASS</span><span class="w"> </span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
<span class="w">  </span><span class="n">g_return_if_fail</span><span class="w"> </span><span class="p">(</span><span class="n">klass</span><span class="o">-&gt;</span><span class="n">open</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>

<span class="w">  </span><span class="n">klass</span><span class="o">-&gt;</span><span class="n">open</span><span class="w"> </span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">error</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>The code above simply redirects the open call to the relevant virtual&nbsp;function.</p>
<p>It is possible to provide a default implementation for this class method in
the object’s <code>class_init</code> function: initialize the <code>klass-&gt;open</code> field to a
pointer to the actual implementation. By default, class methods that are not
inherited are initialized to <code>NULL</code>, and thus are to be considered “pure&nbsp;virtual”.</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">viewer_file_real_close</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerFile</span><span class="w">  </span><span class="o">*</span><span class="n">self</span><span class="p">,</span>
<span class="w">                        </span><span class="n">GError</span><span class="w">     </span><span class="o">**</span><span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="cm">/* Default implementation for the virtual method. */</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">viewer_file_class_init</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerFileClass</span><span class="w"> </span><span class="o">*</span><span class="n">klass</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="cm">/* this is not necessary, except for demonstration purposes.</span>
<span class="cm">   *</span>
<span class="cm">   * pure virtual method: mandates implementation in children.</span>
<span class="cm">   */</span>
<span class="w">  </span><span class="n">klass</span><span class="o">-&gt;</span><span class="n">open</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>

<span class="w">  </span><span class="cm">/* merely virtual method. */</span>
<span class="w">  </span><span class="n">klass</span><span class="o">-&gt;</span><span class="n">close</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">viewer_file_real_close</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">viewer_file_open</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerFile</span><span class="w">  </span><span class="o">*</span><span class="n">self</span><span class="p">,</span>
<span class="w">                  </span><span class="n">GError</span><span class="w">     </span><span class="o">**</span><span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">ViewerFileClass</span><span class="w"> </span><span class="o">*</span><span class="n">klass</span><span class="p">;</span>

<span class="w">  </span><span class="n">g_return_if_fail</span><span class="w"> </span><span class="p">(</span><span class="n">VIEWER_IS_FILE</span><span class="w"> </span><span class="p">(</span><span class="n">self</span><span class="p">));</span>
<span class="w">  </span><span class="n">g_return_if_fail</span><span class="w"> </span><span class="p">(</span><span class="n">error</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">*</span><span class="n">error</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>

<span class="w">  </span><span class="n">klass</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VIEWER_FILE_GET_CLASS</span><span class="w"> </span><span class="p">(</span><span class="n">self</span><span class="p">);</span>

<span class="w">  </span><span class="cm">/* if the method is purely virtual, then it is a good idea to</span>
<span class="cm">   * check that it has been overridden before calling it, and,</span>
<span class="cm">   * depending on the intent of the class, either ignore it silently</span>
<span class="cm">   * or warn the user.</span>
<span class="cm">   */</span>
<span class="w">  </span><span class="n">g_return_if_fail</span><span class="w"> </span><span class="p">(</span><span class="n">klass</span><span class="o">-&gt;</span><span class="n">open</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
<span class="w">  </span><span class="n">klass</span><span class="o">-&gt;</span><span class="n">open</span><span class="w"> </span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">error</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">viewer_file_close</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerFile</span><span class="w">  </span><span class="o">*</span><span class="n">self</span><span class="p">,</span>
<span class="w">                   </span><span class="n">GError</span><span class="w">     </span><span class="o">**</span><span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">ViewerFileClass</span><span class="w"> </span><span class="o">*</span><span class="n">klass</span><span class="p">;</span>

<span class="w">  </span><span class="n">g_return_if_fail</span><span class="w"> </span><span class="p">(</span><span class="n">VIEWER_IS_FILE</span><span class="w"> </span><span class="p">(</span><span class="n">self</span><span class="p">));</span>
<span class="w">  </span><span class="n">g_return_if_fail</span><span class="w"> </span><span class="p">(</span><span class="n">error</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">*</span><span class="n">error</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>

<span class="w">  </span><span class="n">klass</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VIEWER_FILE_GET_CLASS</span><span class="w"> </span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">klass</span><span class="o">-&gt;</span><span class="n">close</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">    </span><span class="n">klass</span><span class="o">-&gt;</span><span class="n">close</span><span class="w"> </span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">error</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<h4 id="virtual-private-methods">Virtual private Methods<a class="md-anchor" href="#virtual-private-methods" title="Permanent link"></a></h4>
<p>These are very similar to virtual public methods. They just don’t have a
public function to call directly. The header file contains only a
declaration of the virtual&nbsp;function:</p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* declaration in viewer-file.h. */</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">_ViewerFileClass</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">GObjectClass</span><span class="w"> </span><span class="n">parent</span><span class="p">;</span>

<span class="w">  </span><span class="cm">/* Public virtual method as before. */</span>
<span class="w">  </span><span class="kt">void</span><span class="w">     </span><span class="p">(</span><span class="o">*</span><span class="n">open</span><span class="p">)</span><span class="w">           </span><span class="p">(</span><span class="n">ViewerFile</span><span class="w">  </span><span class="o">*</span><span class="n">self</span><span class="p">,</span>
<span class="w">                              </span><span class="n">GError</span><span class="w">     </span><span class="o">**</span><span class="n">error</span><span class="p">);</span>

<span class="w">  </span><span class="cm">/* Private helper function to work out whether the file can be loaded via</span>
<span class="cm">   * memory mapped I/O, or whether it has to be read as a stream. */</span>
<span class="w">  </span><span class="n">gboolean</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">can_memory_map</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerFile</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">);</span>

<span class="w">  </span><span class="cm">/* Padding to allow adding up to 12 new virtual functions without</span>
<span class="cm">   * breaking ABI. */</span>
<span class="w">  </span><span class="n">gpointer</span><span class="w"> </span><span class="n">padding</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
<span class="p">};</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">viewer_file_open</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerFile</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">GError</span><span class="w"> </span><span class="o">**</span><span class="n">error</span><span class="p">);</span>
</code></pre></div>

<p>These virtual functions are often used to delegate part of the job to child&nbsp;classes:</p>
<div class="codehilite"><pre><span></span><code><span class="cm">/* this accessor function is static: it is not exported outside of this file. */</span>
<span class="k">static</span><span class="w"> </span><span class="n">gboolean</span>
<span class="nf">viewer_file_can_memory_map</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerFile</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">VIEWER_FILE_GET_CLASS</span><span class="w"> </span><span class="p">(</span><span class="n">self</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">can_memory_map</span><span class="w"> </span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">viewer_file_open</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerFile</span><span class="w">  </span><span class="o">*</span><span class="n">self</span><span class="p">,</span>
<span class="w">                  </span><span class="n">GError</span><span class="w">     </span><span class="o">**</span><span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">g_return_if_fail</span><span class="w"> </span><span class="p">(</span><span class="n">VIEWER_IS_FILE</span><span class="w"> </span><span class="p">(</span><span class="n">self</span><span class="p">));</span>
<span class="w">  </span><span class="n">g_return_if_fail</span><span class="w"> </span><span class="p">(</span><span class="n">error</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">*</span><span class="n">error</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>

<span class="w">  </span><span class="cm">/*</span>
<span class="cm">   * Try to load the file using memory mapped I/O, if the implementation of the</span>
<span class="cm">   * class determines that is possible using its private virtual method.</span>
<span class="cm">   */</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">viewer_file_can_memory_map</span><span class="w"> </span><span class="p">(</span><span class="n">self</span><span class="p">))</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="cm">/* Load the file using memory mapped I/O. */</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="k">else</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="cm">/* Fall back to trying to load the file using streaming I/O… */</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>Again, it is possible to provide a default implementation for this private virtual&nbsp;function:</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="n">gboolean</span>
<span class="nf">viewer_file_real_can_memory_map</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerFile</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="cm">/* As an example, always return false. Or, potentially return true if the</span>
<span class="cm">   * file is local. */</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">FALSE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">viewer_file_class_init</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerFileClass</span><span class="w"> </span><span class="o">*</span><span class="n">klass</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="cm">/* non-pure virtual method; does not have to be implemented in children. */</span>
<span class="w">  </span><span class="n">klass</span><span class="o">-&gt;</span><span class="n">can_memory_map</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">viewer_file_real_can_memory_map</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>Derived classes can then override the method with code such&nbsp;as:</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">viewer_audio_file_class_init</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerAudioFileClass</span><span class="w"> </span><span class="o">*</span><span class="n">klass</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">ViewerFileClass</span><span class="w"> </span><span class="o">*</span><span class="n">file_class</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VIEWER_FILE_CLASS</span><span class="w"> </span><span class="p">(</span><span class="n">klass</span><span class="p">);</span>

<span class="w">  </span><span class="cm">/* implement pure virtual function. */</span>
<span class="w">  </span><span class="n">file_class</span><span class="o">-&gt;</span><span class="n">can_memory_map</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">viewer_audio_file_can_memory_map</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="chaining-up">Chaining up<a class="md-anchor" href="#chaining-up" title="Permanent link"></a></h3>
<p>Chaining up is often loosely defined by the following set of&nbsp;conditions:</p>
<ul>
<li>parent class A defines a public virtual method named <code>foo</code> and provides a
  default&nbsp;implementation</li>
<li>child class B re-implements method <code>foo</code></li>
<li>B’s implementation of <code>foo</code> calls (‘chains up to’) its parent class A’s
  implementation of <code>foo</code></li>
</ul>
<p>There are various uses of this&nbsp;idiom:</p>
<ul>
<li>you need to extend the behaviour of a class without modifying its code.
  You create a subclass to inherit its implementation, re-implement a public
  virtual method to modify the behaviour and chain up to ensure that the
  previous behaviour is not really modified, just&nbsp;extended</li>
<li>you need to implement the
  <a href="https://en.wikipedia.org/wiki/Chain-of-responsibility_pattern">Chain of Responsibility pattern</a>:
  each object of the inheritance tree chains up to its parent (typically, at the
  beginning or the end of the method) to ensure that each handler is run in&nbsp;turn</li>
</ul>
<p>To explicitly chain up to the implementation of the virtual method in the
parent class, you first need a handle to the original parent class
structure. This pointer can then be used to access the original virtual
function pointer and invoke it&nbsp;directly</p>
<p>The “original” adjective used in the sentence above is not innocuous. To
fully understand its meaning, recall how class structures are initialized:
for each object type, the class structure associated with this object is
created by first copying the class structure of its parent type (a simple
memcpy) and then by invoking the <code>class_init</code> callback on the resulting class
structure. Since the <code>class_init</code> callback is responsible for overwriting the
class structure with the user re-implementations of the class methods, the
modified copy of the parent class structure stored in the derived instance
cannot be used. A copy of the class structure of an instance of the parent
class is&nbsp;needed.</p>
<p>To chain up, you can use the <code>parent_class</code> pointer created and initialized
by the <code>G_DEFINE_TYPE</code> family of macros, for&nbsp;instance:</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">b_method_to_call</span><span class="w"> </span><span class="p">(</span><span class="n">B</span><span class="w"> </span><span class="o">*</span><span class="n">obj</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">some_param</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="cm">/* do stuff before chain up */</span>

<span class="w">  </span><span class="cm">/* call the method_to_call() virtual function on the</span>
<span class="cm">   * parent of BClass, AClass.</span>
<span class="cm">   *</span>
<span class="cm">   * remember the explicit cast to AClass*</span>
<span class="cm">   */</span>
<span class="w">  </span><span class="n">A_CLASS</span><span class="w"> </span><span class="p">(</span><span class="n">b_parent_class</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">method_to_call</span><span class="w"> </span><span class="p">(</span><span class="n">obj</span><span class="p">,</span><span class="w"> </span><span class="n">some_param</span><span class="p">);</span>

<span class="w">  </span><span class="cm">/* do stuff after chain up */</span>
<span class="p">}</span>
</code></pre></div>

<h2 id="how-to-define-and-implement-interfaces">How to define and implement interfaces<a class="md-anchor" href="#how-to-define-and-implement-interfaces" title="Permanent link"></a></h2>
<h3 id="defining-interfaces">Defining interfaces<a class="md-anchor" href="#defining-interfaces" title="Permanent link"></a></h3>
<p>The theory behind how GObject interfaces work is given in the section called
<a href="concepts.html#non-instantiatable-classed-types-interfaces">“Non-instantiatable classed types:
interfaces”</a>;
this section covers how to define and implement an&nbsp;interface.</p>
<p>The first step is to get the header right. This interface defines three&nbsp;methods:</p>
<div class="codehilite"><pre><span></span><code><span class="cm">/*</span>
<span class="cm"> * Copyright/Licensing information.</span>
<span class="cm"> */</span>

<span class="cp">#pragma once</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;glib-object.h&gt;</span>

<span class="n">G_BEGIN_DECLS</span>

<span class="cp">#define VIEWER_TYPE_EDITABLE viewer_editable_get_type()</span>
<span class="n">G_DECLARE_INTERFACE</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerEditable</span><span class="p">,</span><span class="w"> </span><span class="n">viewer_editable</span><span class="p">,</span><span class="w"> </span><span class="n">VIEWER</span><span class="p">,</span><span class="w"> </span><span class="n">EDITABLE</span><span class="p">,</span><span class="w"> </span><span class="n">GObject</span><span class="p">)</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">_ViewerEditableInterface</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">GTypeInterface</span><span class="w"> </span><span class="n">parent_iface</span><span class="p">;</span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">save</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerEditable</span><span class="w">  </span><span class="o">*</span><span class="n">self</span><span class="p">,</span>
<span class="w">                </span><span class="n">GError</span><span class="w">         </span><span class="o">**</span><span class="n">error</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">undo</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerEditable</span><span class="w">  </span><span class="o">*</span><span class="n">self</span><span class="p">,</span>
<span class="w">                </span><span class="n">guint</span><span class="w">            </span><span class="n">n_steps</span><span class="p">);</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">redo</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerEditable</span><span class="w">  </span><span class="o">*</span><span class="n">self</span><span class="p">,</span>
<span class="w">                </span><span class="n">guint</span><span class="w">            </span><span class="n">n_steps</span><span class="p">);</span>
<span class="p">};</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">viewer_editable_save</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerEditable</span><span class="w">  </span><span class="o">*</span><span class="n">self</span><span class="p">,</span>
<span class="w">                           </span><span class="n">GError</span><span class="w">         </span><span class="o">**</span><span class="n">error</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">viewer_editable_undo</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerEditable</span><span class="w">  </span><span class="o">*</span><span class="n">self</span><span class="p">,</span>
<span class="w">                           </span><span class="n">guint</span><span class="w">            </span><span class="n">n_steps</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">viewer_editable_redo</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerEditable</span><span class="w">  </span><span class="o">*</span><span class="n">self</span><span class="p">,</span>
<span class="w">                           </span><span class="n">guint</span><span class="w">            </span><span class="n">n_steps</span><span class="p">);</span>

<span class="n">G_END_DECLS</span>
</code></pre></div>

<p>This code is the same as the code for a normal GType which derives from a
GObject except for a few&nbsp;details:</p>
<ul>
<li>the <code>_GET_CLASS</code> function is called <code>_GET_IFACE</code> (and is defined by <code>G_DECLARE_INTERFACE</code>)</li>
<li>the instance type, <code>ViewerEditable</code>, is not fully defined: it is used merely as an abstract type which represents an instance of whatever object which implements the&nbsp;interface</li>
<li>the parent of the <code>ViewerEditableInterface</code> is <code>GTypeInterface</code>, not <code>GObjectClass</code></li>
</ul>
<p>The implementation of the <code>ViewerEditable</code> type itself is&nbsp;trivial:</p>
<ul>
<li><code>G_DEFINE_INTERFACE</code> creates a <code>viewer_editable_get_type</code> function which registers the type in the type system. The third argument is used to define a prerequisite interface (which we’ll talk about more later). Just pass 0 for this argument when an interface has no&nbsp;prerequisite</li>
<li><code>viewer_editable_default_init</code> is expected to register the interface’s signals if there are any (we will see a bit later how to use&nbsp;them)</li>
<li>the interface methods <code>viewer_editable_save</code>, <code>viewer_editable_undo</code> and <code>viewer_editable_redo</code> dereference the interface structure to access its associated interface function and call&nbsp;it</li>
</ul>
<div class="codehilite"><pre><span></span><code><span class="n">G_DEFINE_INTERFACE</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerEditable</span><span class="p">,</span><span class="w"> </span><span class="n">viewer_editable</span><span class="p">,</span><span class="w"> </span><span class="n">G_TYPE_OBJECT</span><span class="p">)</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="n">viewer_editable_default_init</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerEditableInterface</span><span class="w"> </span><span class="o">*</span><span class="n">iface</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/* add properties and signals to the interface here */</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="n">viewer_editable_save</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerEditable</span><span class="w">  </span><span class="o">*</span><span class="n">self</span><span class="p">,</span>
<span class="w">                      </span><span class="n">GError</span><span class="w">         </span><span class="o">**</span><span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">ViewerEditableInterface</span><span class="w"> </span><span class="o">*</span><span class="n">iface</span><span class="p">;</span>

<span class="w">  </span><span class="n">g_return_if_fail</span><span class="w"> </span><span class="p">(</span><span class="n">VIEWER_IS_EDITABLE</span><span class="w"> </span><span class="p">(</span><span class="n">self</span><span class="p">));</span>
<span class="w">  </span><span class="n">g_return_if_fail</span><span class="w"> </span><span class="p">(</span><span class="n">error</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">*</span><span class="n">error</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>

<span class="w">  </span><span class="n">iface</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VIEWER_EDITABLE_GET_IFACE</span><span class="w"> </span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
<span class="w">  </span><span class="n">g_return_if_fail</span><span class="w"> </span><span class="p">(</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">save</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
<span class="w">  </span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">save</span><span class="w"> </span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">error</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="n">viewer_editable_undo</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerEditable</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">,</span>
<span class="w">                      </span><span class="n">guint</span><span class="w">           </span><span class="n">n_steps</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">ViewerEditableInterface</span><span class="w"> </span><span class="o">*</span><span class="n">iface</span><span class="p">;</span>

<span class="w">  </span><span class="n">g_return_if_fail</span><span class="w"> </span><span class="p">(</span><span class="n">VIEWER_IS_EDITABLE</span><span class="w"> </span><span class="p">(</span><span class="n">self</span><span class="p">));</span>

<span class="w">  </span><span class="n">iface</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VIEWER_EDITABLE_GET_IFACE</span><span class="w"> </span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
<span class="w">  </span><span class="n">g_return_if_fail</span><span class="w"> </span><span class="p">(</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">undo</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
<span class="w">  </span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">undo</span><span class="w"> </span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">n_steps</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="n">viewer_editable_redo</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerEditable</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">,</span>
<span class="w">                      </span><span class="n">guint</span><span class="w">           </span><span class="n">n_steps</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">ViewerEditableInterface</span><span class="w"> </span><span class="o">*</span><span class="n">iface</span><span class="p">;</span>

<span class="w">  </span><span class="n">g_return_if_fail</span><span class="w"> </span><span class="p">(</span><span class="n">VIEWER_IS_EDITABLE</span><span class="w"> </span><span class="p">(</span><span class="n">self</span><span class="p">));</span>

<span class="w">  </span><span class="n">iface</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VIEWER_EDITABLE_GET_IFACE</span><span class="w"> </span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
<span class="w">  </span><span class="n">g_return_if_fail</span><span class="w"> </span><span class="p">(</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">redo</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
<span class="w">  </span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">redo</span><span class="w"> </span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">n_steps</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="implementing-interfaces">Implementing interfaces<a class="md-anchor" href="#implementing-interfaces" title="Permanent link"></a></h3>
<p>Once the interface is defined, implementing it is rather&nbsp;trivial.</p>
<p>The first step is to define a normal final GObject class exactly as&nbsp;usual.</p>
<p>The second step is to implement <code>ViewerFile</code> by defining it using
<code>G_DEFINE_TYPE_WITH_CODE</code> and <code>G_IMPLEMENT_INTERFACE</code> instead of
<code>G_DEFINE_TYPE</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">viewer_file_editable_interface_init</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerEditableInterface</span><span class="w"> </span><span class="o">*</span><span class="n">iface</span><span class="p">);</span>

<span class="n">G_DEFINE_TYPE_WITH_CODE</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerFile</span><span class="p">,</span><span class="w"> </span><span class="n">viewer_file</span><span class="p">,</span><span class="w"> </span><span class="n">G_TYPE_OBJECT</span><span class="p">,</span>
<span class="w">                         </span><span class="n">G_IMPLEMENT_INTERFACE</span><span class="w"> </span><span class="p">(</span><span class="n">VIEWER_TYPE_EDITABLE</span><span class="p">,</span>
<span class="w">                                                </span><span class="n">viewer_file_editable_interface_init</span><span class="p">))</span>
</code></pre></div>

<p>This definition is very much like all the similar functions seen previously.
The only interface-specific code present here is the use of
<code>G_IMPLEMENT_INTERFACE</code>.</p>
<p>Classes can implement multiple interfaces by using multiple calls to
<code>G_IMPLEMENT_INTERFACE</code> inside the call to <code>G_DEFINE_TYPE_WITH_CODE</code>.</p>
<p><code>viewer_file_editable_interface_init</code> is the interface initialization
function: inside it, every virtual method of the interface must be assigned
to its&nbsp;implementation:</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">viewer_file_editable_save</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerFile</span><span class="w">  </span><span class="o">*</span><span class="n">self</span><span class="p">,</span>
<span class="w">                           </span><span class="n">GError</span><span class="w">     </span><span class="o">**</span><span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">g_print</span><span class="w"> </span><span class="p">(</span><span class="s">"File implementation of editable interface save method: %s.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
<span class="w">           </span><span class="n">self</span><span class="o">-&gt;</span><span class="n">filename</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">viewer_file_editable_undo</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerFile</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">,</span>
<span class="w">                           </span><span class="n">guint</span><span class="w">       </span><span class="n">n_steps</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">g_print</span><span class="w"> </span><span class="p">(</span><span class="s">"File implementation of editable interface undo method: %s.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
<span class="w">           </span><span class="n">self</span><span class="o">-&gt;</span><span class="n">filename</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">viewer_file_editable_redo</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerFile</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">,</span>
<span class="w">                           </span><span class="n">guint</span><span class="w">       </span><span class="n">n_steps</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">g_print</span><span class="w"> </span><span class="p">(</span><span class="s">"File implementation of editable interface redo method: %s.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
<span class="w">           </span><span class="n">self</span><span class="o">-&gt;</span><span class="n">filename</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">viewer_file_editable_interface_init</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerEditableInterface</span><span class="w"> </span><span class="o">*</span><span class="n">iface</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">save</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">viewer_file_editable_save</span><span class="p">;</span>
<span class="w">  </span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">undo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">viewer_file_editable_undo</span><span class="p">;</span>
<span class="w">  </span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">redo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">viewer_file_editable_redo</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">viewer_file_init</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerFile</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="cm">/* Instance variable initialisation code. */</span>
<span class="p">}</span>
</code></pre></div>

<p>If the object is not of final type, e.g. was declared using
<code>G_DECLARE_DERIVABLE_TYPE</code> then <code>G_ADD_PRIVATE</code> macro should be added. The
private structure should be declared exactly as for a normal derivable&nbsp;object.</p>
<div class="codehilite"><pre><span></span><code><span class="n">G_DEFINE_TYPE_WITH_CODE</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerFile</span><span class="p">,</span><span class="w"> </span><span class="n">viewer_file</span><span class="p">,</span><span class="w"> </span><span class="n">G_TYPE_OBJECT</span><span class="p">,</span>
<span class="w">                         </span><span class="n">G_ADD_PRIVATE</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerFile</span><span class="p">)</span>
<span class="w">                         </span><span class="n">G_IMPLEMENT_INTERFACE</span><span class="w"> </span><span class="p">(</span><span class="n">VIEWER_TYPE_EDITABLE</span><span class="p">,</span>
<span class="w">                                                </span><span class="n">viewer_file_editable_interface_init</span><span class="p">))</span>
</code></pre></div>

<h3 id="interface-definition-prerequisites">Interface definition prerequisites<a class="md-anchor" href="#interface-definition-prerequisites" title="Permanent link"></a></h3>
<p>To specify that an interface requires the presence of other interfaces when
implemented, GObject introduces the concept of prerequisites: it is possible
to associate a list of prerequisite types to an interface. For example, if
object A wishes to implement interface I1, and if interface I1 has a
prerequisite on interface I2, A has to implement both I1 and&nbsp;I2.</p>
<p>The mechanism described above is, in practice, very similar to Java’s
interface I1 extends interface I2. The example below shows the GObject&nbsp;equivalent:</p>
<div class="codehilite"><pre><span></span><code>/* Make the ViewerEditableLossy interface require ViewerEditable interface. */
G_DEFINE_INTERFACE (ViewerEditableLossy, viewer_editable_lossy, VIEWER_TYPE_EDITABLE)
</code></pre></div>

<p>In the <code>G_DEFINE_INTERFACE</code> call above, the third parameter defines the
prerequisite type. This is the GType of either an interface or a class. In
this case the <code>ViewerEditable</code> interface is a prerequisite of
<code>ViewerEditableLossy</code>. The code below shows how an implementation can
implement both interfaces and register their&nbsp;implementations:</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">viewer_file_editable_lossy_compress</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerEditableLossy</span><span class="w"> </span><span class="o">*</span><span class="n">editable</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">ViewerFile</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VIEWER_FILE</span><span class="w"> </span><span class="p">(</span><span class="n">editable</span><span class="p">);</span>

<span class="w">  </span><span class="n">g_print</span><span class="w"> </span><span class="p">(</span><span class="s">"File implementation of lossy editable interface compress method: %s.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
<span class="w">           </span><span class="n">self</span><span class="o">-&gt;</span><span class="n">filename</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">viewer_file_editable_lossy_interface_init</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerEditableLossyInterface</span><span class="w"> </span><span class="o">*</span><span class="n">iface</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">compress</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">viewer_file_editable_lossy_compress</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">viewer_file_editable_save</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerEditable</span><span class="w">  </span><span class="o">*</span><span class="n">editable</span><span class="p">,</span>
<span class="w">                           </span><span class="n">GError</span><span class="w">         </span><span class="o">**</span><span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">ViewerFile</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VIEWER_FILE</span><span class="w"> </span><span class="p">(</span><span class="n">editable</span><span class="p">);</span>

<span class="w">  </span><span class="n">g_print</span><span class="w"> </span><span class="p">(</span><span class="s">"File implementation of editable interface save method: %s.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
<span class="w">           </span><span class="n">self</span><span class="o">-&gt;</span><span class="n">filename</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">viewer_file_editable_undo</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerEditable</span><span class="w"> </span><span class="o">*</span><span class="n">editable</span><span class="p">,</span>
<span class="w">                           </span><span class="n">guint</span><span class="w">           </span><span class="n">n_steps</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">ViewerFile</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VIEWER_FILE</span><span class="w"> </span><span class="p">(</span><span class="n">editable</span><span class="p">);</span>

<span class="w">  </span><span class="n">g_print</span><span class="w"> </span><span class="p">(</span><span class="s">"File implementation of editable interface undo method: %s.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
<span class="w">           </span><span class="n">self</span><span class="o">-&gt;</span><span class="n">filename</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">viewer_file_editable_redo</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerEditable</span><span class="w"> </span><span class="o">*</span><span class="n">editable</span><span class="p">,</span>
<span class="w">                           </span><span class="n">guint</span><span class="w">           </span><span class="n">n_steps</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">ViewerFile</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VIEWER_FILE</span><span class="w"> </span><span class="p">(</span><span class="n">editable</span><span class="p">);</span>

<span class="w">  </span><span class="n">g_print</span><span class="w"> </span><span class="p">(</span><span class="s">"File implementation of editable interface redo method: %s.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
<span class="w">           </span><span class="n">self</span><span class="o">-&gt;</span><span class="n">filename</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">viewer_file_editable_interface_init</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerEditableInterface</span><span class="w"> </span><span class="o">*</span><span class="n">iface</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">save</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">viewer_file_editable_save</span><span class="p">;</span>
<span class="w">  </span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">undo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">viewer_file_editable_undo</span><span class="p">;</span>
<span class="w">  </span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">redo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">viewer_file_editable_redo</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">viewer_file_class_init</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerFileClass</span><span class="w"> </span><span class="o">*</span><span class="n">klass</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="cm">/* Nothing here. */</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">viewer_file_init</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerFile</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="cm">/* Instance variable initialisation code. */</span>
<span class="p">}</span>

<span class="n">G_DEFINE_TYPE_WITH_CODE</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerFile</span><span class="p">,</span><span class="w"> </span><span class="n">viewer_file</span><span class="p">,</span><span class="w"> </span><span class="n">G_TYPE_OBJECT</span><span class="p">,</span>
<span class="w">                         </span><span class="n">G_IMPLEMENT_INTERFACE</span><span class="w"> </span><span class="p">(</span><span class="n">VIEWER_TYPE_EDITABLE</span><span class="p">,</span>
<span class="w">                                                </span><span class="n">viewer_file_editable_interface_init</span><span class="p">)</span>
<span class="w">                         </span><span class="n">G_IMPLEMENT_INTERFACE</span><span class="w"> </span><span class="p">(</span><span class="n">VIEWER_TYPE_EDITABLE_LOSSY</span><span class="p">,</span>
<span class="w">                                                </span><span class="n">viewer_file_editable_lossy_interface_init</span><span class="p">))</span>
</code></pre></div>

<p>It is very important to notice that the order in which interface
implementations are added to the main object is not random:
<code>g_type_add_interface_static()</code>, which is called by <code>G_IMPLEMENT_INTERFACE</code>, must
be invoked first on the interfaces which have no prerequisites and then on
the&nbsp;others.</p>
<h3 id="interface-properties">Interface properties<a class="md-anchor" href="#interface-properties" title="Permanent link"></a></h3>
<p>GObject interfaces can also have properties. Declaration of the interface
properties is similar to declaring the properties of ordinary GObject types
as explained in the section called <a href="concepts.html#object-properties">“Object
properties”</a>, except that
<code>g_object_interface_install_property()</code> is used to declare the properties
instead of <code>g_object_class_install_property()</code>.</p>
<p>To include a property named ‘autosave-frequency’ of type gdouble in the
<code>ViewerEditable</code> interface example code above, we only need to add one call in
<code>viewer_editable_default_init()</code> as shown&nbsp;below:</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">viewer_editable_default_init</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerEditableInterface</span><span class="w"> </span><span class="o">*</span><span class="n">iface</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">g_object_interface_install_property</span><span class="w"> </span><span class="p">(</span><span class="n">iface</span><span class="p">,</span>
<span class="w">    </span><span class="n">g_param_spec_double</span><span class="w"> </span><span class="p">(</span><span class="s">"autosave-frequency"</span><span class="p">,</span>
<span class="w">                         </span><span class="s">"Autosave frequency"</span><span class="p">,</span>
<span class="w">                         </span><span class="s">"Frequency (in per-seconds) to autosave backups of the editable content at. "</span>
<span class="w">                         </span><span class="s">"Or zero to disable autosaves."</span><span class="p">,</span>
<span class="w">                         </span><span class="mf">0.0</span><span class="p">,</span><span class="w">  </span><span class="cm">/* minimum */</span>
<span class="w">                         </span><span class="n">G_MAXDOUBLE</span><span class="p">,</span><span class="w">  </span><span class="cm">/* maximum */</span>
<span class="w">                         </span><span class="mf">0.0</span><span class="p">,</span><span class="w">  </span><span class="cm">/* default */</span>
<span class="w">                         </span><span class="n">G_PARAM_READWRITE</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div>

<p>One point worth noting is that the declared property wasn’t assigned an
integer <span class="caps">ID</span>. The reason being that integer IDs of properties are used only
inside the <code>get_property</code> and <code>set_property</code> virtual methods. Since interfaces
declare but do not implement properties, there is no need to assign integer
IDs to&nbsp;them.</p>
<p>An implementation declares and defines its properties in the usual way as
explained in the section called “Object properties”, except for one small
change: it can declare the properties of the interface it implements using
<code>g_object_class_override_property()</code> instead of <code>g_object_class_install_property()</code>.
The following code snippet shows the modifications needed in the <code>ViewerFile</code>
declaration and implementation&nbsp;above:</p>
<div class="codehilite"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">_ViewerFile</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">GObject</span><span class="w"> </span><span class="n">parent_instance</span><span class="p">;</span>

<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">autosave_frequency</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">PROP_AUTOSAVE_FREQUENCY</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">  </span><span class="n">N_PROPERTIES</span>
<span class="p">};</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">viewer_file_set_property</span><span class="w"> </span><span class="p">(</span><span class="n">GObject</span><span class="w">      </span><span class="o">*</span><span class="n">object</span><span class="p">,</span>
<span class="w">                          </span><span class="n">guint</span><span class="w">         </span><span class="n">prop_id</span><span class="p">,</span>
<span class="w">                          </span><span class="k">const</span><span class="w"> </span><span class="n">GValue</span><span class="w"> </span><span class="o">*</span><span class="n">value</span><span class="p">,</span>
<span class="w">                          </span><span class="n">GParamSpec</span><span class="w">   </span><span class="o">*</span><span class="n">pspec</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">ViewerFile</span><span class="w"> </span><span class="o">*</span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VIEWER_FILE</span><span class="w"> </span><span class="p">(</span><span class="n">object</span><span class="p">);</span>

<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">prop_id</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">PROP_AUTOSAVE_FREQUENCY</span><span class="p">:</span>
<span class="w">      </span><span class="n">file</span><span class="o">-&gt;</span><span class="n">autosave_frequency</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g_value_get_double</span><span class="w"> </span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span>

<span class="w">    </span><span class="k">default</span><span class="o">:</span>
<span class="w">      </span><span class="n">G_OBJECT_WARN_INVALID_PROPERTY_ID</span><span class="w"> </span><span class="p">(</span><span class="n">object</span><span class="p">,</span><span class="w"> </span><span class="n">prop_id</span><span class="p">,</span><span class="w"> </span><span class="n">pspec</span><span class="p">);</span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">viewer_file_get_property</span><span class="w"> </span><span class="p">(</span><span class="n">GObject</span><span class="w">    </span><span class="o">*</span><span class="n">object</span><span class="p">,</span>
<span class="w">                          </span><span class="n">guint</span><span class="w">       </span><span class="n">prop_id</span><span class="p">,</span>
<span class="w">                          </span><span class="n">GValue</span><span class="w">     </span><span class="o">*</span><span class="n">value</span><span class="p">,</span>
<span class="w">                          </span><span class="n">GParamSpec</span><span class="w"> </span><span class="o">*</span><span class="n">pspec</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">ViewerFile</span><span class="w"> </span><span class="o">*</span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VIEWER_FILE</span><span class="w"> </span><span class="p">(</span><span class="n">object</span><span class="p">);</span>

<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">prop_id</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">PROP_AUTOSAVE_FREQUENCY</span><span class="p">:</span>
<span class="w">      </span><span class="n">g_value_set_double</span><span class="w"> </span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">file</span><span class="o">-&gt;</span><span class="n">autosave_frequency</span><span class="p">);</span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span>

<span class="w">    </span><span class="k">default</span><span class="o">:</span>
<span class="w">      </span><span class="n">G_OBJECT_WARN_INVALID_PROPERTY_ID</span><span class="w"> </span><span class="p">(</span><span class="n">object</span><span class="p">,</span><span class="w"> </span><span class="n">prop_id</span><span class="p">,</span><span class="w"> </span><span class="n">pspec</span><span class="p">);</span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">viewer_file_class_init</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerFileClass</span><span class="w"> </span><span class="o">*</span><span class="n">klass</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">GObjectClass</span><span class="w"> </span><span class="o">*</span><span class="n">object_class</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">G_OBJECT_CLASS</span><span class="w"> </span><span class="p">(</span><span class="n">klass</span><span class="p">);</span>

<span class="w">  </span><span class="n">object_class</span><span class="o">-&gt;</span><span class="n">set_property</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">viewer_file_set_property</span><span class="p">;</span>
<span class="w">  </span><span class="n">object_class</span><span class="o">-&gt;</span><span class="n">get_property</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">viewer_file_get_property</span><span class="p">;</span>

<span class="w">  </span><span class="n">g_object_class_override_property</span><span class="w"> </span><span class="p">(</span><span class="n">object_class</span><span class="p">,</span><span class="w"> </span><span class="n">PROP_AUTOSAVE_FREQUENCY</span><span class="p">,</span><span class="w"> </span><span class="s">"autosave-frequency"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="overriding-interface-methods">Overriding interface methods<a class="md-anchor" href="#overriding-interface-methods" title="Permanent link"></a></h3>
<p>If a base class already implements an interface and a derived class needs to
implement the same interface but needs to override certain methods, you must
reimplement the interface and set only the interface methods which need&nbsp;overriding.</p>
<p>In this example, <code>ViewerAudioFile</code> is derived from <code>ViewerFile</code>. Both implement
the <code>ViewerEditable</code> interface. <code>ViewerAudioFile</code> only implements one method of
the <code>ViewerEditable</code> interface and uses the base class implementation of the&nbsp;other.</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">viewer_audio_file_editable_save</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerEditable</span><span class="w">  </span><span class="o">*</span><span class="n">editable</span><span class="p">,</span>
<span class="w">                                 </span><span class="n">GError</span><span class="w">         </span><span class="o">**</span><span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">ViewerAudioFile</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VIEWER_AUDIO_FILE</span><span class="w"> </span><span class="p">(</span><span class="n">editable</span><span class="p">);</span>

<span class="w">  </span><span class="n">g_print</span><span class="w"> </span><span class="p">(</span><span class="s">"Audio file implementation of editable interface save method.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">viewer_audio_file_editable_interface_init</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerEditableInterface</span><span class="w"> </span><span class="o">*</span><span class="n">iface</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="cm">/* Override the implementation of save(). */</span>
<span class="w">  </span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">save</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">viewer_audio_file_editable_save</span><span class="p">;</span>

<span class="w">  </span><span class="cm">/*</span>
<span class="cm">   * Leave iface-&gt;undo and -&gt;redo alone, they are already set to the</span>
<span class="cm">   * base class implementation.</span>
<span class="cm">   */</span>
<span class="p">}</span>

<span class="n">G_DEFINE_TYPE_WITH_CODE</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerAudioFile</span><span class="p">,</span><span class="w"> </span><span class="n">viewer_audio_file</span><span class="p">,</span><span class="w"> </span><span class="n">VIEWER_TYPE_FILE</span><span class="p">,</span>
<span class="w">                         </span><span class="n">G_IMPLEMENT_INTERFACE</span><span class="w"> </span><span class="p">(</span><span class="n">VIEWER_TYPE_EDITABLE</span><span class="p">,</span>
<span class="w">                                                </span><span class="n">viewer_audio_file_editable_interface_init</span><span class="p">))</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="n">viewer_audio_file_class_init</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerAudioFileClass</span><span class="w"> </span><span class="o">*</span><span class="n">klass</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="cm">/* Nothing here. */</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="n">viewer_audio_file_init</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerAudioFile</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="cm">/* Nothing here. */</span>
<span class="p">}</span>
</code></pre></div>

<p>To access the base class interface implementation use
<code>g_type_interface_peek_parent()</code> from within an interface’s <code>default_init</code>
function.</p>
<p>To call the base class implementation of an interface method from a derived
class where than interface method has been overridden, stash away the
pointer returned from <code>g_type_interface_peek_parent()</code> in a global&nbsp;variable.</p>
<p>In this example <code>ViewerAudioFile</code> overrides the save interface method. In
its overridden method it calls the base class implementation of the same
interface&nbsp;method.</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="n">ViewerEditableInterface</span><span class="w"> </span><span class="o">*</span><span class="n">viewer_editable_parent_interface</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">viewer_audio_file_editable_save</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerEditable</span><span class="w">  </span><span class="o">*</span><span class="n">editable</span><span class="p">,</span>
<span class="w">                                 </span><span class="n">GError</span><span class="w">         </span><span class="o">**</span><span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">ViewerAudioFile</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VIEWER_AUDIO_FILE</span><span class="w"> </span><span class="p">(</span><span class="n">editable</span><span class="p">);</span>

<span class="w">  </span><span class="n">g_print</span><span class="w"> </span><span class="p">(</span><span class="s">"Audio file implementation of editable interface save method.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

<span class="w">  </span><span class="cm">/* Now call the base implementation */</span>
<span class="w">  </span><span class="n">viewer_editable_parent_interface</span><span class="o">-&gt;</span><span class="n">save</span><span class="w"> </span><span class="p">(</span><span class="n">editable</span><span class="p">,</span><span class="w"> </span><span class="n">error</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">viewer_audio_file_editable_interface_init</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerEditableInterface</span><span class="w"> </span><span class="o">*</span><span class="n">iface</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">viewer_editable_parent_interface</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g_type_interface_peek_parent</span><span class="w"> </span><span class="p">(</span><span class="n">iface</span><span class="p">);</span>

<span class="w">  </span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">save</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">viewer_audio_file_editable_save</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">G_DEFINE_TYPE_WITH_CODE</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerAudioFile</span><span class="p">,</span><span class="w"> </span><span class="n">viewer_audio_file</span><span class="p">,</span><span class="w"> </span><span class="n">VIEWER_TYPE_FILE</span><span class="p">,</span>
<span class="w">                         </span><span class="n">G_IMPLEMENT_INTERFACE</span><span class="w"> </span><span class="p">(</span><span class="n">VIEWER_TYPE_EDITABLE</span><span class="p">,</span>
<span class="w">                                                </span><span class="n">viewer_audio_file_editable_interface_init</span><span class="p">))</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="n">viewer_audio_file_class_init</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerAudioFileClass</span><span class="w"> </span><span class="o">*</span><span class="n">klass</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="cm">/* Nothing here. */</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="n">viewer_audio_file_init</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerAudioFile</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="cm">/* Nothing here. */</span>
<span class="p">}</span>
</code></pre></div>

<h2 id="how-to-create-and-use-signals">How to create and use signals<a class="md-anchor" href="#how-to-create-and-use-signals" title="Permanent link"></a></h2>
<p>The signal system in GType is pretty complex and flexible: it is possible
for its users to connect at runtime any number of callbacks (implemented in
any language for which a binding exists) to any signal and to stop the
emission of any signal at any state of the signal emission process. This
flexibility makes it possible to use GSignal for much more than just
emitting signals to multiple&nbsp;clients.</p>
<h3 id="simple-use-of-signals">Simple use of signals<a class="md-anchor" href="#simple-use-of-signals" title="Permanent link"></a></h3>
<p>The most basic use of signals is to implement event notification. For
example, given a <code>ViewerFile</code> object with a write method, a signal could be
emitted whenever the file is changed using that method. The code below shows
how the user can connect a callback to the “changed”&nbsp;signal.</p>
<div class="codehilite"><pre><span></span><code><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g_object_new</span><span class="w"> </span><span class="p">(</span><span class="n">VIEWER_FILE_TYPE</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>

<span class="n">g_signal_connect</span><span class="w"> </span><span class="p">(</span><span class="n">file</span><span class="p">,</span><span class="w"> </span><span class="s">"changed"</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">GCallback</span><span class="p">)</span><span class="w"> </span><span class="n">changed_event</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>

<span class="n">viewer_file_write</span><span class="w"> </span><span class="p">(</span><span class="n">file</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="n">strlen</span><span class="w"> </span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>
</code></pre></div>

<p>The ViewerFile signal is registered in the <code>class_init</code> function:</p>
<div class="codehilite"><pre><span></span><code><span class="n">file_signals</span><span class="p">[</span><span class="n">CHANGED</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>
<span class="w">  </span><span class="n">g_signal_newv</span><span class="w"> </span><span class="p">(</span><span class="s">"changed"</span><span class="p">,</span>
<span class="w">                 </span><span class="n">G_TYPE_FROM_CLASS</span><span class="w"> </span><span class="p">(</span><span class="n">object_class</span><span class="p">),</span>
<span class="w">                 </span><span class="n">G_SIGNAL_RUN_LAST</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">G_SIGNAL_NO_RECURSE</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">G_SIGNAL_NO_HOOKS</span><span class="p">,</span>
<span class="w">                 </span><span class="nb">NULL</span><span class="w"> </span><span class="cm">/* closure */</span><span class="p">,</span>
<span class="w">                 </span><span class="nb">NULL</span><span class="w"> </span><span class="cm">/* accumulator */</span><span class="p">,</span>
<span class="w">                 </span><span class="nb">NULL</span><span class="w"> </span><span class="cm">/* accumulator data */</span><span class="p">,</span>
<span class="w">                 </span><span class="nb">NULL</span><span class="w"> </span><span class="cm">/* C marshaller */</span><span class="p">,</span>
<span class="w">                 </span><span class="n">G_TYPE_NONE</span><span class="w"> </span><span class="cm">/* return_type */</span><span class="p">,</span>
<span class="w">                 </span><span class="mi">0</span><span class="w">     </span><span class="cm">/* n_params */</span><span class="p">,</span>
<span class="w">                 </span><span class="nb">NULL</span><span class="w">  </span><span class="cm">/* param_types */</span><span class="p">);</span>
</code></pre></div>

<p>and the signal is emitted in <code>viewer_file_write</code>:</p>
<div class="codehilite"><pre><span></span><code><span class="kt">void</span>
<span class="nf">viewer_file_write</span><span class="w"> </span><span class="p">(</span><span class="n">ViewerFile</span><span class="w">   </span><span class="o">*</span><span class="n">self</span><span class="p">,</span>
<span class="w">                   </span><span class="k">const</span><span class="w"> </span><span class="n">guint8</span><span class="w"> </span><span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
<span class="w">                   </span><span class="n">gsize</span><span class="w">         </span><span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">g_return_if_fail</span><span class="w"> </span><span class="p">(</span><span class="n">VIEWER_IS_FILE</span><span class="w"> </span><span class="p">(</span><span class="n">self</span><span class="p">));</span>
<span class="w">  </span><span class="n">g_return_if_fail</span><span class="w"> </span><span class="p">(</span><span class="n">buffer</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="w">  </span><span class="cm">/* First write data. */</span>

<span class="w">  </span><span class="cm">/* Then, notify user of data written. */</span>
<span class="w">  </span><span class="n">g_signal_emit</span><span class="w"> </span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">file_signals</span><span class="p">[</span><span class="n">CHANGED</span><span class="p">],</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="cm">/* details */</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>As shown above, the details parameter can safely be set to zero if no detail
needs to be conveyed. For a discussion of what it can be used for, see the
section called <a href="concepts.html#the-detail-argument">“The detail argument”</a>.</p>
<p>The C signal marshaller should always be <code>NULL</code>, in which case the best
marshaller for the given closure type will be chosen by GLib. This may be an
internal marshaller specific to the closure type, or
<code>g_cclosure_marshal_generic()</code>, which implements generic conversion of arrays of
parameters to C callback invocations. GLib used to require the user to write
or generate a type-specific marshaller and pass that, but that has been
deprecated in favour of automatic selection of&nbsp;marshallers.</p>
<p>Note that <code>g_cclosure_marshal_generic()</code> is slower than non-generic
marshallers, so should be avoided for performance critical code. However,
performance critical code should rarely be using signals anyway, as signals
are synchronous, and the emission blocks until all listeners are invoked,
which has potentially unbounded&nbsp;cost.</p>
    </div>
  </section>
</section>


    



    <section id="search" class="content hidden"></section>

    <footer>
    
    </footer>
  </div>



</body><!-- Mirrored from docs.gtk.org/gobject/tutorial.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 16 Dec 2024 17:55:03 GMT --></html>